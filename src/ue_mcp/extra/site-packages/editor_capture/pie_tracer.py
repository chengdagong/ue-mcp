# PIE (Play In Editor) actor transform tracing for UE5
#
# Traces specified actors' transforms (location, rotation, velocity) during PIE
# runtime using PIETickExecutor for tick-based execution.
#
# Optionally captures screenshots of tracked actors at each sample interval.

import unreal
import os
import json
import math
from datetime import datetime

from .pie_tick_executor import PIETickExecutor


# ============================================
# VIEW CONFIGURATIONS FOR SCREENSHOTS
# ============================================

PIE_TRACER_VIEWS = [
    {"name": "front", "display_name": "Front View", "yaw": 180, "pitch": 0},
    {"name": "side", "display_name": "Side View", "yaw": 90, "pitch": 0},
    {"name": "back", "display_name": "Back View", "yaw": 0, "pitch": 0},
    {"name": "perspective", "display_name": "45-Degree Perspective", "yaw": -135, "pitch": -35},
]


def _ensure_output_directory(path):
    """
    Ensure output directory exists, creating it if necessary.

    Args:
        path: File path to ensure parent directory exists
    """
    dir_path = os.path.dirname(path)
    if dir_path and not os.path.exists(dir_path):
        os.makedirs(dir_path)
        unreal.log(f"[INFO] Created output directory: {dir_path}")


def _ensure_directory(path):
    """
    Ensure directory exists, creating it if necessary.

    Args:
        path: Directory path to ensure exists
    """
    if not os.path.exists(path):
        os.makedirs(path)
        unreal.log(f"[INFO] Created directory: {path}")


# ============================================
# PIE TRACER CLASS
# ============================================

class PIETracer:
    """PIE actor transform tracer using PIETickExecutor with optional screenshot capture."""

    # Assumed FPS for time-to-tick conversion
    ASSUMED_FPS = 60

    def __init__(
        self,
        output_dir,
        actor_names,
        interval_seconds=0.1,
        duration=None,
        auto_stop_pie=True,
        task_id=None,
        tick_callbacks=None,
        # Screenshot capture options
        capture_screenshots=False,
        camera_distance=300,
        target_height=90,
        resolution=(800, 600),
        multi_angle=True,
        views=None,
    ):
        """
        Initialize the PIE tracer.

        Args:
            output_dir: Output directory for trace data (will contain actor subdirectories)
            actor_names: List of actor names to track
            interval_seconds: Sampling interval in seconds
            duration: Auto-stop after this many seconds (None = run indefinitely)
            auto_stop_pie: Whether to stop PIE session when duration is reached
            task_id: Unique task identifier for completion file (used by MCP server)
            tick_callbacks: Dict mapping sample numbers to Python code strings to execute.
                           Example: {0: "print('First sample')", 5: "custom_code()"}
                           Code is executed after sampling at the specified sample number.
            capture_screenshots: Whether to capture screenshots of actors (default: False)
            camera_distance: Camera distance from actor for screenshots (default: 300)
            target_height: Target height offset from actor origin (default: 90)
            resolution: Screenshot resolution as (width, height) tuple (default: (800, 600))
            multi_angle: Whether to capture multiple angles (default: True)
            views: Custom view configurations (defaults to PIE_TRACER_VIEWS)
        """
        self.output_dir = output_dir
        self.actor_names = actor_names
        self.interval_seconds = interval_seconds
        self.duration = duration
        self.auto_stop_pie = auto_stop_pie
        self.task_id = task_id
        self.tick_callbacks = tick_callbacks or {}

        # Screenshot capture settings
        self.capture_screenshots = capture_screenshots
        self.camera_distance = camera_distance
        self.target_height = target_height
        self.resolution = resolution
        self.multi_angle = multi_angle
        self.views = views if views is not None else PIE_TRACER_VIEWS

        # Internal executor
        self._executor = None

        # State variables
        self._accumulated_time = 0.0
        self._total_elapsed = 0.0
        self._sample_count = 0
        self._current_tick = 0  # Current tick number from executor
        self._is_running = False
        self._is_complete = False
        self._result = None

        # Actor tracking
        self._actor_refs = {}  # {name: actor_object}
        self._actor_labels = {}  # {name: actor_label} - for directory naming
        self._actors_not_found = []

        # Screenshot state
        self._camera_actor = None
        self._pending_screenshot_task = None
        self._current_screenshot_queue = []  # [(actor_name, view_config, filename), ...]
        self._current_sample_screenshots = {}  # {actor_name: [screenshot_paths]}
        self._is_paused_for_screenshots = False  # Whether game is paused for screenshot capture

        # Metadata (will be written to metadata.json at the end)
        self._metadata = {
            "level": "",
            "start_time": "",
            "end_time": "",
            "duration": 0.0,
            "interval": interval_seconds,
            "sample_count": 0,
            "actors": [],
            "actors_not_found": [],
            "capture_screenshots": capture_screenshots,
        }

        # Ensure output directory exists
        _ensure_directory(self.output_dir)

    def start(self):
        """Start the tracer using PIETickExecutor."""
        if self._is_running:
            unreal.log_warning("[WARNING] PIE tracer already running")
            return

        self._is_running = True
        self._accumulated_time = 0.0
        self._total_elapsed = 0.0
        self._sample_count = 0
        self._current_tick = 0
        self._is_complete = False
        self._result = None
        self._actor_refs = {}
        self._actor_labels = {}
        self._actors_not_found = []

        # Reset screenshot state
        self._camera_actor = None
        self._pending_screenshot_task = None
        self._current_screenshot_queue = []
        self._current_sample_screenshots = {}
        self._is_paused_for_screenshots = False

        # Initialize metadata
        self._metadata = {
            "level": "",
            "start_time": datetime.now().isoformat(),
            "end_time": "",
            "duration": 0.0,
            "interval": self.interval_seconds,
            "sample_count": 0,
            "actors": [],
            "actors_not_found": [],
            "capture_screenshots": self.capture_screenshots,
        }

        # Create camera for screenshots if enabled (must be done BEFORE PIE starts)
        if self.capture_screenshots:
            pie_worlds = unreal.EditorLevelLibrary.get_pie_worlds(False)
            pie_already_running = len(pie_worlds) > 0

            if not pie_already_running:
                self._create_camera()
                if self._camera_actor is None:
                    unreal.log_warning("[WARNING] Failed to create camera, disabling screenshots")
                    self.capture_screenshots = False
            else:
                unreal.log_warning("[WARNING] PIE already running, cannot create camera for screenshots")
                self.capture_screenshots = False

        # Calculate total ticks
        if self.duration is not None:
            total_ticks = int(self.duration * self.ASSUMED_FPS) + 1
        else:
            # Run for a very long time if no duration specified
            total_ticks = 10 * 60 * self.ASSUMED_FPS  # 10 minutes max

        # Build the sampling code that will be executed each tick
        sample_code = self._build_sample_code()

        # Create and configure PIETickExecutor
        # We execute on every tick, but the sample code handles interval timing
        self._executor = PIETickExecutor(
            total_ticks=total_ticks,
            code_snippets=[{
                "code": sample_code,
                "start_tick": 0,
                "execution_count": total_ticks,
            }],
            auto_stop_pie=self.auto_stop_pie,  # Let executor handle PIE stop
            task_id=None,  # We write completion file ourselves
            on_before_complete=self._on_executor_complete,  # Save data before PIE stops
        )

        # Start the executor (this resets exec_context, so we inject after)
        self._executor.start()

        # Inject tracer context into executor AFTER start() which resets the context
        self._executor._exec_context.update({
            "__tracer__": self,
        })

        unreal.log(f"[OK] PIE tracer started - Tracking {len(self.actor_names)} actors")
        unreal.log(f"[INFO] Interval: {self.interval_seconds}s, Output: {self.output_dir}")

    def _build_sample_code(self):
        """Build the sampling code to be executed each tick."""
        # This code will be executed every tick by PIETickExecutor
        # It handles time accumulation, sampling, and screenshot capture internally
        return """
tracer = __tracer__
delta_time = 1.0 / 60.0  # Approximate delta time

# Update current tick from executor (use _tick_count attribute)
tracer._current_tick = __executor__._tick_count

# Track total elapsed time
tracer._total_elapsed += delta_time

# Process any pending screenshots first
if tracer._process_screenshot_queue():
    # Screenshots still in progress, skip other processing
    pass
elif tracer.duration is not None and tracer._total_elapsed >= tracer.duration:
    # Duration reached - trigger executor completion
    # This will call on_before_complete callback before stopping PIE
    __executor__._auto_complete()
else:
    # Accumulate time for interval
    tracer._accumulated_time += delta_time

    # Check if sample interval reached
    if tracer._accumulated_time >= tracer.interval_seconds:
        tracer._accumulated_time -= tracer.interval_seconds
        tracer._do_sample()
"""

    def _do_sample(self):
        """Perform a single sample of all tracked actors."""
        # Get PIE world
        pie_worlds = unreal.EditorLevelLibrary.get_pie_worlds(False)
        if len(pie_worlds) == 0:
            return  # PIE not running

        pie_world = pie_worlds[0]

        # Get level name on first sample
        if self._sample_count == 0:
            level_name = pie_world.get_name()
            self._metadata["level"] = level_name

        # Lazy actor discovery on first sample
        if not self._actor_refs and self._sample_count == 0:
            found_count = self._find_actors(pie_world)
            if found_count == 0:
                unreal.log_error("[ERROR] No actors found to track, stopping tracer")
                # Trigger executor completion to stop cleanly
                if self._executor:
                    self._executor._auto_complete()
                return

        # Get current tick for directory naming
        tick = self._current_tick

        # Prepare screenshot tracking for this sample
        self._current_sample_screenshots = {}

        # Sample each tracked actor and write transform.json
        for name, actor in self._actor_refs.items():
            try:
                # Get actor label for directory naming
                actor_label = self._actor_labels.get(name, name)
                safe_label = self._sanitize_dirname(actor_label)

                # Create sample directory: output_dir/{actor_label}/sample_at_tick_{tick}/
                sample_dir = os.path.join(self.output_dir, safe_label, f"sample_at_tick_{tick}")
                _ensure_directory(sample_dir)

                # Sample transform data
                sample_data = self._sample_actor(actor, self._total_elapsed, tick)

                # Create screenshots directory if capturing
                if self.capture_screenshots:
                    screenshots_dir = os.path.join(sample_dir, "screenshots")
                    _ensure_directory(screenshots_dir)

                # Write transform.json immediately
                transform_file = os.path.join(sample_dir, "transform.json")
                with open(transform_file, "w", encoding="utf-8") as f:
                    json.dump(sample_data, f, indent=2)

                # Store sample directory for screenshot capture
                self._current_sample_screenshots[name] = {
                    "sample_dir": sample_dir,
                    "screenshots": [],
                }

            except (RuntimeError, ReferenceError):
                # Actor was destroyed during PIE
                unreal.log_warning(f"[WARNING] Actor '{name}' is no longer valid, skipping")
                continue

        self._sample_count += 1

        # Start screenshot capture if enabled
        if self.capture_screenshots and self._camera_actor is not None:
            self._start_screenshot_capture()

            # Pause the game while capturing screenshots
            # This ensures screenshots are taken at the exact moment of transform sampling
            if self._current_screenshot_queue:
                self._pause_game(True)

        # Execute tick callback if registered for this sample number
        self._execute_tick_callback(self._sample_count - 1)

    def _sanitize_dirname(self, name):
        """
        Sanitize a string for use as a directory name.

        Args:
            name: String to sanitize

        Returns:
            Sanitized string safe for directory names
        """
        # Replace problematic characters
        safe = name.replace(" ", "_").replace("/", "_").replace("\\", "_")
        safe = safe.replace(":", "_").replace("*", "_").replace("?", "_")
        safe = safe.replace("\"", "_").replace("<", "_").replace(">", "_")
        safe = safe.replace("|", "_")
        return safe

    def stop(self):
        """Stop the tracer."""
        if not self._is_running:
            unreal.log_warning("[WARNING] PIE tracer not running")
            return

        self._is_running = False

        # Resume game if paused
        if self._is_paused_for_screenshots:
            self._pause_game(False)

        # Stop the executor
        if self._executor is not None:
            self._executor.stop()
            self._executor = None

        # Destroy camera if exists
        self._destroy_camera()

        unreal.log(f"[OK] PIE tracer stopped - Total samples: {self._sample_count}")

    def _find_actors(self, pie_world):
        """
        Find actor references by name in PIE world using fuzzy matching.

        Matching priority (stops at first match):
        1. Exact match on object name (actor.get_name())
        2. Exact match on label (actor.get_actor_label())
        3. Exact match on class name (actor.get_class().get_name())
        4. Partial match on object name (contains)
        5. Partial match on label (contains)
        6. Partial match on class name (contains)

        Returns:
            Number of actors successfully found
        """
        all_actors = unreal.GameplayStatics.get_all_actors_of_class(
            pie_world, unreal.Actor
        )

        # Build lookup tables for efficient matching
        actors_by_name = {}      # object name -> actor
        actors_by_label = {}     # label -> actor
        actors_by_class = {}     # class name -> [actors]

        for actor in all_actors:
            obj_name = actor.get_name().lower()
            label = actor.get_actor_label().lower()
            class_name = actor.get_class().get_name().lower()

            actors_by_name[obj_name] = actor
            actors_by_label[label] = actor
            if class_name not in actors_by_class:
                actors_by_class[class_name] = []
            actors_by_class[class_name].append(actor)

        for target_name in self.actor_names:
            target_lower = target_name.lower()
            found_actor = None
            match_type = None

            # 1. Exact match on object name
            if target_lower in actors_by_name:
                found_actor = actors_by_name[target_lower]
                match_type = "name"

            # 2. Exact match on label
            if not found_actor and target_lower in actors_by_label:
                found_actor = actors_by_label[target_lower]
                match_type = "label"

            # 3. Exact match on class name
            if not found_actor and target_lower in actors_by_class:
                actors = actors_by_class[target_lower]
                if len(actors) > 1:
                    unreal.log_warning(
                        f"[WARNING] Multiple actors of class '{target_name}', using first"
                    )
                found_actor = actors[0]
                match_type = "class"

            # 4. Partial match on object name (contains)
            # Only match if target is a significant substring (at least 4 chars)
            # to avoid overly aggressive matching
            if not found_actor and len(target_lower) >= 4:
                for obj_name, actor in actors_by_name.items():
                    # Only allow partial match if target is fully contained in name
                    # Don't match if name is contained in target (too aggressive)
                    if target_lower in obj_name:
                        found_actor = actor
                        match_type = "name (partial)"
                        break

            # 5. Partial match on label (contains)
            if not found_actor and len(target_lower) >= 4:
                for label, actor in actors_by_label.items():
                    if target_lower in label:
                        found_actor = actor
                        match_type = "label (partial)"
                        break

            # 6. Partial match on class name (contains)
            if not found_actor and len(target_lower) >= 4:
                for class_name, actors in actors_by_class.items():
                    if target_lower in class_name:
                        if len(actors) > 1:
                            unreal.log_warning(
                                f"[WARNING] Multiple actors match class '{target_name}', using first"
                            )
                        found_actor = actors[0]
                        match_type = "class (partial)"
                        break

            if found_actor:
                self._actor_refs[target_name] = found_actor
                # Save actor label for directory naming (prefer label over name)
                actual_label = found_actor.get_actor_label()
                actual_name = found_actor.get_name()
                # Use label if not empty, otherwise use object name
                self._actor_labels[target_name] = actual_label if actual_label else actual_name
                actual_class = found_actor.get_class().get_name()
                unreal.log(f"[OK] Found actor: {target_name} -> {actual_label} ({actual_class}) [matched by {match_type}]")
            else:
                self._actors_not_found.append(target_name)
                unreal.log_warning(f"[WARNING] Actor not found: {target_name}")

        return len(self._actor_refs)

    def _sample_actor(self, actor, timestamp, tick):
        """
        Sample a single actor's transform data.

        Args:
            actor: Actor to sample
            timestamp: Current timestamp in seconds
            tick: Current tick number from executor

        Returns:
            dict with tick, timestamp, location, rotation, velocity, screenshots
        """
        # Get location
        loc = actor.get_actor_location()

        # Get rotation
        rot = actor.get_actor_rotation()

        # Get velocity (if available)
        velocity = None
        if hasattr(actor, 'get_velocity'):
            try:
                vel = actor.get_velocity()
                if vel:  # Check not None
                    velocity = {"x": vel.x, "y": vel.y, "z": vel.z}
            except (AttributeError, RuntimeError):
                pass  # Actor doesn't support velocity

        return {
            "tick": tick,
            "timestamp": round(timestamp, 3),
            "location": {"x": round(loc.x, 2), "y": round(loc.y, 2), "z": round(loc.z, 2)},
            "rotation": {"pitch": round(rot.pitch, 2), "yaw": round(rot.yaw, 2), "roll": round(rot.roll, 2)},
            "velocity": velocity,
            "screenshots": [],  # Will be populated if screenshots are enabled
        }

    # ============================================
    # SCREENSHOT CAPTURE METHODS
    # ============================================

    def _create_camera(self):
        """Create camera actor for screenshot capture."""
        actor_subsystem = unreal.get_editor_subsystem(unreal.EditorActorSubsystem)
        if not actor_subsystem:
            unreal.log_error("[ERROR] Failed to get EditorActorSubsystem")
            return

        self._camera_actor = actor_subsystem.spawn_actor_from_class(
            unreal.CameraActor,
            unreal.Vector(0, 0, 0),
            transient=True
        )
        if self._camera_actor:
            self._camera_actor.set_actor_label("PIE_Tracer_Camera")
            unreal.log("[OK] Created screenshot camera")
        else:
            unreal.log_error("[ERROR] Failed to create camera actor")

    def _destroy_camera(self):
        """Destroy the camera actor if it exists."""
        if self._camera_actor is not None:
            try:
                if unreal.SystemLibrary.is_valid(self._camera_actor):
                    self._camera_actor.destroy_actor()
            except Exception:
                pass  # Camera already destroyed
            self._camera_actor = None

    def _pause_game(self, paused):
        """
        Pause or resume the game during PIE.

        Args:
            paused: True to pause, False to resume
        """
        if paused == self._is_paused_for_screenshots:
            return  # Already in desired state

        pie_worlds = unreal.EditorLevelLibrary.get_pie_worlds(False)
        if len(pie_worlds) == 0:
            return

        pie_world = pie_worlds[0]

        try:
            # Use PIE world directly as world context
            unreal.GameplayStatics.set_game_paused(pie_world, paused)
            self._is_paused_for_screenshots = paused
            state = "paused" if paused else "resumed"
            unreal.log(f"[OK] Game {state} for screenshot capture")
        except Exception as e:
            unreal.log_error(f"[ERROR] Failed to {('pause' if paused else 'resume')} game: {e}")

    def _calculate_camera_transform(self, target_location, view_config):
        """
        Calculate camera position and rotation for a given view.

        Args:
            target_location: Target location (unreal.Vector)
            view_config: View configuration dict with name, yaw, pitch

        Returns:
            tuple: (camera_location, camera_rotation)
        """
        yaw = view_config["yaw"]
        pitch = view_config["pitch"]

        # Calculate camera position using spherical coordinates
        yaw_rad = math.radians(yaw)
        pitch_rad = math.radians(pitch)

        # Calculate offset from target
        horizontal_dist = self.camera_distance * math.cos(pitch_rad)
        vertical_offset = self.camera_distance * math.sin(-pitch_rad)

        offset_x = horizontal_dist * math.cos(yaw_rad)
        offset_y = horizontal_dist * math.sin(yaw_rad)
        offset_z = vertical_offset + self.target_height

        camera_location = unreal.Vector(
            target_location.x + offset_x,
            target_location.y + offset_y,
            target_location.z + offset_z
        )

        # Camera rotation - look at target
        # Yaw needs to point toward target (opposite of offset direction)
        look_yaw = yaw + 180
        camera_rotation = unreal.Rotator(roll=0, pitch=pitch, yaw=look_yaw)

        return camera_location, camera_rotation

    def _start_screenshot_capture(self):
        """Start capturing screenshots for all tracked actors in current sample."""
        # Build the screenshot queue for this sample
        self._current_screenshot_queue = []
        tick = self._current_tick

        for actor_name, actor in self._actor_refs.items():
            try:
                if not unreal.SystemLibrary.is_valid(actor):
                    continue

                # Get sample info
                sample_info = self._current_sample_screenshots.get(actor_name)
                if not sample_info:
                    continue

                sample_dir = sample_info["sample_dir"]
                screenshots_dir = os.path.join(sample_dir, "screenshots")

                # Get views to capture
                if self.multi_angle:
                    views_to_capture = self.views
                else:
                    # Single angle: just front view
                    views_to_capture = [self.views[0]] if self.views else []

                for view_config in views_to_capture:
                    # Generate filename: {output_dir}/{actor_label}/sample_at_tick_{tick}/screenshots/{view}.png
                    view_name = view_config["name"]
                    filename = os.path.join(screenshots_dir, f"{view_name}.png")

                    # Queue this screenshot
                    self._current_screenshot_queue.append({
                        "actor_name": actor_name,
                        "actor": actor,
                        "view_config": view_config,
                        "filename": filename,
                        "sample_dir": sample_dir,
                    })

            except (RuntimeError, ReferenceError):
                continue

        # Start processing the queue
        if self._current_screenshot_queue:
            unreal.log(f"[INFO] Starting screenshot capture for tick #{tick} ({len(self._current_screenshot_queue)} shots)")

    def _process_screenshot_queue(self):
        """
        Process pending screenshots in the queue.

        Returns:
            True if there are still screenshots being processed, False otherwise
        """
        # Check if previous screenshot task is complete
        if self._pending_screenshot_task is not None:
            if not self._pending_screenshot_task.is_task_done():
                # Still waiting for screenshot to complete
                return True
            # Task completed, clear it
            self._pending_screenshot_task = None

        # Check if there are more screenshots to take
        if not self._current_screenshot_queue:
            # Queue empty - resume game if it was paused
            if self._is_paused_for_screenshots:
                self._pause_game(False)
            return False

        # Take next screenshot
        shot_info = self._current_screenshot_queue.pop(0)
        self._take_screenshot(shot_info)
        return True

    def _take_screenshot(self, shot_info):
        """
        Take a single screenshot.

        Args:
            shot_info: Dict with actor_name, actor, view_config, filename, sample_dir
        """
        actor = shot_info["actor"]
        view_config = shot_info["view_config"]
        filename = shot_info["filename"]
        actor_name = shot_info["actor_name"]
        sample_dir = shot_info["sample_dir"]

        try:
            if not unreal.SystemLibrary.is_valid(actor):
                unreal.log_warning(f"[WARNING] Actor {actor_name} no longer valid, skipping screenshot")
                return

            # Get actor location
            target_location = actor.get_actor_location()

            # Calculate camera transform
            cam_pos, cam_rot = self._calculate_camera_transform(target_location, view_config)

            # Move camera
            self._camera_actor.set_actor_location_and_rotation(
                cam_pos, cam_rot, sweep=False, teleport=True
            )

            # Ensure loading is complete before screenshot
            unreal.AutomationLibrary.finish_loading_before_screenshot()

            # Take screenshot
            self._pending_screenshot_task = unreal.AutomationLibrary.take_high_res_screenshot(
                res_x=self.resolution[0],
                res_y=self.resolution[1],
                filename=filename,
                camera=self._camera_actor,
                mask_enabled=False,
                capture_hdr=False,
                comparison_tolerance=unreal.ComparisonTolerance.LOW,
                comparison_notes="",
                delay=0.0,
                force_game_view=True
            )

            # Record screenshot in sample info (just the view name, not full path)
            view_name = view_config["name"]
            sample_info = self._current_sample_screenshots.get(actor_name)
            if sample_info:
                sample_info["screenshots"].append(f"{view_name}.png")

                # Update transform.json with screenshot list
                transform_file = os.path.join(sample_dir, "transform.json")
                if os.path.exists(transform_file):
                    try:
                        with open(transform_file, "r", encoding="utf-8") as f:
                            transform_data = json.load(f)
                        transform_data["screenshots"] = sample_info["screenshots"]
                        with open(transform_file, "w", encoding="utf-8") as f:
                            json.dump(transform_data, f, indent=2)
                    except Exception as e:
                        unreal.log_warning(f"[WARNING] Failed to update transform.json: {e}")

            unreal.log(f"[OK] Screenshot: {actor_name}/{view_name} -> {os.path.basename(filename)}")

        except Exception as e:
            unreal.log_error(f"[ERROR] Failed to take screenshot for {actor_name}: {e}")

    def _execute_tick_callback(self, sample_number):
        """
        Execute tick callback code for a specific sample number.

        Args:
            sample_number: The sample number (0-indexed) to check for callbacks
        """
        if sample_number not in self.tick_callbacks:
            return

        code = self.tick_callbacks[sample_number]
        if not code:
            return

        try:
            # Create execution context with useful variables
            exec_globals = {
                "unreal": unreal,
                "sample_number": sample_number,
                "total_elapsed": self._total_elapsed,
                "actor_refs": self._actor_refs,
                "metadata": self._metadata,
            }
            exec(code, exec_globals)
            unreal.log(f"[OK] Executed tick callback for sample #{sample_number}")
        except Exception as e:
            unreal.log_error(f"[ERROR] Tick callback for sample #{sample_number} failed: {e}")

    def _on_executor_complete(self, executor):
        """
        Called by executor before stopping PIE.

        This is the on_before_complete callback that saves metadata.json
        while PIE is still running.

        Args:
            executor: The PIETickExecutor instance
        """
        if self._is_complete:
            return  # Already completed

        unreal.log(f"[INFO] Tracer completing - saving metadata...")

        # Update metadata
        self._metadata["duration"] = round(self._total_elapsed, 3)
        self._metadata["sample_count"] = self._sample_count
        self._metadata["end_time"] = datetime.now().isoformat()
        self._metadata["actors"] = list(self._actor_labels.values())
        self._metadata["actors_not_found"] = self._actors_not_found

        # Write metadata.json
        metadata_file = os.path.join(self.output_dir, "metadata.json")
        try:
            with open(metadata_file, "w", encoding="utf-8") as f:
                json.dump(self._metadata, f, indent=2)
            unreal.log(f"[OK] Wrote metadata file: {metadata_file}")
        except Exception as e:
            unreal.log_error(f"[ERROR] Failed to write metadata file: {e}")

        # Build result
        self._result = {
            "success": True,
            "output_dir": self.output_dir,
            "duration": self._total_elapsed,
            "interval": self.interval_seconds,
            "sample_count": self._sample_count,
            "actor_count": len(self._actor_refs),
            "actors_not_found": self._actors_not_found,
        }

        # Resume game if paused before stopping PIE
        if self._is_paused_for_screenshots:
            self._pause_game(False)

        # Destroy camera before PIE stops
        self._destroy_camera()

        # Mark as complete (executor will stop PIE and itself)
        self._is_complete = True
        self._is_running = False
        self._executor = None

        screenshot_info = " with screenshots" if self.capture_screenshots else ""
        unreal.log(f"[OK] PIE tracing completed - {self._sample_count} samples in {self._total_elapsed:.1f}s{screenshot_info}")
        unreal.log(f"[OK] Output directory: {self.output_dir}")

        # Write completion file for MCP server to detect
        if self.task_id:
            project_dir = unreal.Paths.project_dir()
            completion_file = os.path.join(project_dir, "Saved", "Logs", f"{self.task_id}_completed")
            with open(completion_file, "w", encoding="utf-8") as f:
                json.dump(self._result, f)
            unreal.log(f"[OK] Wrote completion file: {completion_file}")

    @property
    def is_complete(self):
        """Check if tracing has completed (duration reached or manually stopped)."""
        return self._is_complete

    def get_result(self):
        """
        Get the trace result.

        Returns:
            dict with success, output_file, duration, interval, sample_count, actor_count, actors_not_found
            or None if not complete
        """
        return self._result


# ============================================
# MODULE-LEVEL FUNCTIONS
# ============================================

# Global instance
_tracer_instance = None


def start_pie_tracer(
    output_dir,
    actor_names,
    interval_seconds=0.1,
    auto_start_pie=False,
    duration=None,
    auto_stop_pie=True,
    task_id=None,
    tick_callbacks=None,
    # Screenshot capture options
    capture_screenshots=False,
    camera_distance=300,
    target_height=90,
    resolution=(800, 600),
    multi_angle=True,
    views=None,
):
    """
    Start PIE actor tracer.

    Args:
        output_dir: Output directory for trace data (will contain actor subdirectories)
        actor_names: List of actor names to track
        interval_seconds: Sampling interval in seconds
        auto_start_pie: Whether to auto-start PIE
        duration: Auto-stop after this many seconds
        auto_stop_pie: Whether to stop PIE when duration reached
        task_id: Unique task identifier for completion file
        tick_callbacks: Dict mapping sample numbers to Python code strings to execute.
                       Example: {0: "print('First sample')", 5: "custom_code()"}
        capture_screenshots: Whether to capture screenshots of actors (default: False)
        camera_distance: Camera distance from actor for screenshots (default: 300)
        target_height: Target height offset from actor origin (default: 90)
        resolution: Screenshot resolution as (width, height) tuple (default: (800, 600))
        multi_angle: Whether to capture multiple angles (default: True)
        views: Custom view configurations (defaults to PIE_TRACER_VIEWS)

    Returns:
        PIETracer instance
    """
    global _tracer_instance

    if _tracer_instance is not None:
        _tracer_instance.stop()

    _tracer_instance = PIETracer(
        output_dir=output_dir,
        actor_names=actor_names,
        interval_seconds=interval_seconds,
        duration=duration,
        auto_stop_pie=auto_stop_pie,
        task_id=task_id,
        tick_callbacks=tick_callbacks,
        capture_screenshots=capture_screenshots,
        camera_distance=camera_distance,
        target_height=target_height,
        resolution=resolution,
        multi_angle=multi_angle,
        views=views,
    )
    _tracer_instance.start()

    # Auto-start PIE if requested (use executor's public method)
    if auto_start_pie and _tracer_instance._executor:
        _tracer_instance._executor.request_start_pie()

    return _tracer_instance


def stop_pie_tracer():
    """Stop PIE actor tracer."""
    global _tracer_instance
    if _tracer_instance is not None:
        _tracer_instance.stop()
        _tracer_instance = None


def get_pie_tracer():
    """Get current tracer instance."""
    return _tracer_instance
