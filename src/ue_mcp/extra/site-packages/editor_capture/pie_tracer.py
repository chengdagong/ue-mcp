# PIE (Play In Editor) actor transform tracing for UE5
#
# Traces specified actors' transforms (location, rotation, velocity) during PIE
# runtime using PIETickExecutor for tick-based execution.

import unreal
import os
import json
from datetime import datetime

from .pie_tick_executor import PIETickExecutor, _start_pie_session, _stop_pie_session


def _ensure_output_directory(path):
    """
    Ensure output directory exists, creating it if necessary.

    Args:
        path: File path to ensure parent directory exists
    """
    dir_path = os.path.dirname(path)
    if dir_path and not os.path.exists(dir_path):
        os.makedirs(dir_path)
        unreal.log(f"[INFO] Created output directory: {dir_path}")


# ============================================
# PIE TRACER CLASS
# ============================================

class PIETracer:
    """PIE actor transform tracer using PIETickExecutor."""

    # Assumed FPS for time-to-tick conversion
    ASSUMED_FPS = 60

    def __init__(
        self,
        output_file,
        actor_names,
        interval_seconds=0.1,
        duration=None,
        auto_stop_pie=True,
        task_id=None,
        tick_callbacks=None
    ):
        """
        Initialize the PIE tracer.

        Args:
            output_file: JSON output file path
            actor_names: List of actor names to track
            interval_seconds: Sampling interval in seconds
            duration: Auto-stop after this many seconds (None = run indefinitely)
            auto_stop_pie: Whether to stop PIE session when duration is reached
            task_id: Unique task identifier for completion file (used by MCP server)
            tick_callbacks: Dict mapping sample numbers to Python code strings to execute.
                           Example: {0: "print('First sample')", 5: "custom_code()"}
                           Code is executed after sampling at the specified sample number.
        """
        self.output_file = output_file
        self.actor_names = actor_names
        self.interval_seconds = interval_seconds
        self.duration = duration
        self.auto_stop_pie = auto_stop_pie
        self.task_id = task_id
        self.tick_callbacks = tick_callbacks or {}

        # Internal executor
        self._executor = None

        # State variables
        self._accumulated_time = 0.0
        self._total_elapsed = 0.0
        self._sample_count = 0
        self._is_running = False
        self._is_complete = False
        self._result = None

        # Actor tracking
        self._actor_refs = {}  # {name: actor_object}
        self._actors_not_found = []

        # Trace data
        self._trace_data = {
            "actors": {},  # {actor_name: [samples]}
            "metadata": {
                "level": "",
                "start_time": "",
                "end_time": "",
                "duration": 0.0,
                "interval": interval_seconds,
                "sample_count": 0,
            }
        }

        # Ensure output directory exists
        _ensure_output_directory(self.output_file)

    def start(self):
        """Start the tracer using PIETickExecutor."""
        if self._is_running:
            unreal.log_warning("[WARNING] PIE tracer already running")
            return

        self._is_running = True
        self._accumulated_time = 0.0
        self._total_elapsed = 0.0
        self._sample_count = 0
        self._is_complete = False
        self._result = None
        self._actor_refs = {}
        self._actors_not_found = []

        # Initialize trace data
        self._trace_data = {
            "actors": {},
            "metadata": {
                "level": "",
                "start_time": datetime.now().isoformat(),
                "end_time": "",
                "duration": 0.0,
                "interval": self.interval_seconds,
                "sample_count": 0,
            }
        }

        # Calculate total ticks
        if self.duration is not None:
            total_ticks = int(self.duration * self.ASSUMED_FPS) + 1
        else:
            # Run for a very long time if no duration specified
            total_ticks = 10 * 60 * self.ASSUMED_FPS  # 10 minutes max

        # Build the sampling code that will be executed each tick
        sample_code = self._build_sample_code()

        # Create and configure PIETickExecutor
        # We execute on every tick, but the sample code handles interval timing
        self._executor = PIETickExecutor(
            total_ticks=total_ticks,
            code_snippets=[{
                "code": sample_code,
                "start_tick": 0,
                "execution_count": total_ticks,
            }],
            auto_stop_pie=False,  # We handle this ourselves
            task_id=None,  # We write completion file ourselves
        )

        # Inject tracer context into executor
        self._executor._exec_context.update({
            "__tracer__": self,
        })

        # Start the executor
        self._executor.start()

        unreal.log(f"[OK] PIE tracer started - Tracking {len(self.actor_names)} actors")
        unreal.log(f"[INFO] Interval: {self.interval_seconds}s, Output: {self.output_file}")

    def _build_sample_code(self):
        """Build the sampling code to be executed each tick."""
        # This code will be executed every tick by PIETickExecutor
        # It handles time accumulation and sampling internally
        return """
tracer = __tracer__
delta_time = 1.0 / 60.0  # Approximate delta time

# Track total elapsed time
tracer._total_elapsed += delta_time

# Check if duration reached
if tracer.duration is not None and tracer._total_elapsed >= tracer.duration:
    tracer._auto_complete()
else:
    # Accumulate time for interval
    tracer._accumulated_time += delta_time

    # Check if sample interval reached
    if tracer._accumulated_time >= tracer.interval_seconds:
        tracer._accumulated_time -= tracer.interval_seconds
        tracer._do_sample()
"""

    def _do_sample(self):
        """Perform a single sample of all tracked actors."""
        # Get PIE world
        pie_worlds = unreal.EditorLevelLibrary.get_pie_worlds(False)
        if len(pie_worlds) == 0:
            return  # PIE not running

        pie_world = pie_worlds[0]

        # Get level name on first sample
        if self._sample_count == 0:
            level_name = pie_world.get_name()
            self._trace_data["metadata"]["level"] = level_name

        # Lazy actor discovery on first sample
        if not self._actor_refs and self._sample_count == 0:
            found_count = self._find_actors(pie_world)
            if found_count == 0:
                unreal.log_error("[ERROR] No actors found to track, stopping tracer")
                self._auto_complete()
                return

        # Sample each tracked actor
        for name, actor in self._actor_refs.items():
            try:
                sample = self._sample_actor(actor, self._total_elapsed)
                self._trace_data["actors"][name].append(sample)
            except (RuntimeError, ReferenceError):
                # Actor was destroyed during PIE
                unreal.log_warning(f"[WARNING] Actor '{name}' is no longer valid, skipping")
                continue

        self._sample_count += 1

        # Execute tick callback if registered for this sample number
        self._execute_tick_callback(self._sample_count - 1)

    def stop(self):
        """Stop the tracer."""
        if not self._is_running:
            unreal.log_warning("[WARNING] PIE tracer not running")
            return

        self._is_running = False

        # Stop the executor
        if self._executor is not None:
            self._executor.stop()
            self._executor = None

        unreal.log(f"[OK] PIE tracer stopped - Total samples: {self._sample_count}")

    def _find_actors(self, pie_world):
        """
        Find actor references by name in PIE world using fuzzy matching.

        Matching priority (stops at first match):
        1. Exact match on object name (actor.get_name())
        2. Exact match on label (actor.get_actor_label())
        3. Exact match on class name (actor.get_class().get_name())
        4. Partial match on object name (contains)
        5. Partial match on label (contains)
        6. Partial match on class name (contains)

        Returns:
            Number of actors successfully found
        """
        all_actors = unreal.GameplayStatics.get_all_actors_of_class(
            pie_world, unreal.Actor
        )

        # Build lookup tables for efficient matching
        actors_by_name = {}      # object name -> actor
        actors_by_label = {}     # label -> actor
        actors_by_class = {}     # class name -> [actors]

        for actor in all_actors:
            obj_name = actor.get_name().lower()
            label = actor.get_actor_label().lower()
            class_name = actor.get_class().get_name().lower()

            actors_by_name[obj_name] = actor
            actors_by_label[label] = actor
            if class_name not in actors_by_class:
                actors_by_class[class_name] = []
            actors_by_class[class_name].append(actor)

        for target_name in self.actor_names:
            target_lower = target_name.lower()
            found_actor = None
            match_type = None

            # 1. Exact match on object name
            if target_lower in actors_by_name:
                found_actor = actors_by_name[target_lower]
                match_type = "name"

            # 2. Exact match on label
            if not found_actor and target_lower in actors_by_label:
                found_actor = actors_by_label[target_lower]
                match_type = "label"

            # 3. Exact match on class name
            if not found_actor and target_lower in actors_by_class:
                actors = actors_by_class[target_lower]
                if len(actors) > 1:
                    unreal.log_warning(
                        f"[WARNING] Multiple actors of class '{target_name}', using first"
                    )
                found_actor = actors[0]
                match_type = "class"

            # 4. Partial match on object name (contains)
            if not found_actor:
                for obj_name, actor in actors_by_name.items():
                    if target_lower in obj_name or obj_name in target_lower:
                        found_actor = actor
                        match_type = "name (partial)"
                        break

            # 5. Partial match on label (contains)
            if not found_actor:
                for label, actor in actors_by_label.items():
                    if target_lower in label or label in target_lower:
                        found_actor = actor
                        match_type = "label (partial)"
                        break

            # 6. Partial match on class name (contains)
            if not found_actor:
                for class_name, actors in actors_by_class.items():
                    if target_lower in class_name or class_name in target_lower:
                        if len(actors) > 1:
                            unreal.log_warning(
                                f"[WARNING] Multiple actors match class '{target_name}', using first"
                            )
                        found_actor = actors[0]
                        match_type = "class (partial)"
                        break

            if found_actor:
                self._actor_refs[target_name] = found_actor
                self._trace_data["actors"][target_name] = []
                actual_label = found_actor.get_actor_label()
                actual_class = found_actor.get_class().get_name()
                unreal.log(f"[OK] Found actor: {target_name} -> {actual_label} ({actual_class}) [matched by {match_type}]")
            else:
                self._actors_not_found.append(target_name)
                unreal.log_warning(f"[WARNING] Actor not found: {target_name}")

        return len(self._actor_refs)

    def _sample_actor(self, actor, timestamp):
        """
        Sample a single actor's transform data.

        Args:
            actor: Actor to sample
            timestamp: Current timestamp in seconds

        Returns:
            dict with timestamp, location, rotation, velocity
        """
        # Get location
        loc = actor.get_actor_location()

        # Get rotation
        rot = actor.get_actor_rotation()

        # Get velocity (if available)
        velocity = None
        if hasattr(actor, 'get_velocity'):
            try:
                vel = actor.get_velocity()
                if vel:  # Check not None
                    velocity = {"x": vel.x, "y": vel.y, "z": vel.z}
            except (AttributeError, RuntimeError):
                pass  # Actor doesn't support velocity

        return {
            "timestamp": round(timestamp, 3),
            "location": {"x": round(loc.x, 2), "y": round(loc.y, 2), "z": round(loc.z, 2)},
            "rotation": {"pitch": round(rot.pitch, 2), "yaw": round(rot.yaw, 2), "roll": round(rot.roll, 2)},
            "velocity": velocity,
        }

    def _execute_tick_callback(self, sample_number):
        """
        Execute tick callback code for a specific sample number.

        Args:
            sample_number: The sample number (0-indexed) to check for callbacks
        """
        if sample_number not in self.tick_callbacks:
            return

        code = self.tick_callbacks[sample_number]
        if not code:
            return

        try:
            # Create execution context with useful variables
            exec_globals = {
                "unreal": unreal,
                "sample_number": sample_number,
                "total_elapsed": self._total_elapsed,
                "actor_refs": self._actor_refs,
                "trace_data": self._trace_data,
            }
            exec(code, exec_globals)
            unreal.log(f"[OK] Executed tick callback for sample #{sample_number}")
        except Exception as e:
            unreal.log_error(f"[ERROR] Tick callback for sample #{sample_number} failed: {e}")

    def _auto_complete(self):
        """Auto-complete when duration is reached."""
        if self._is_complete:
            return  # Already completed

        unreal.log(f"[INFO] Duration ({self.duration}s) reached, auto-stopping...")

        # Update metadata
        self._trace_data["metadata"]["duration"] = round(self._total_elapsed, 3)
        self._trace_data["metadata"]["sample_count"] = self._sample_count
        self._trace_data["metadata"]["end_time"] = datetime.now().isoformat()

        # Write trace file
        try:
            with open(self.output_file, "w", encoding="utf-8") as f:
                json.dump(self._trace_data, f, indent=2)
            unreal.log(f"[OK] Wrote trace file: {self.output_file}")
        except Exception as e:
            unreal.log_error(f"[ERROR] Failed to write trace file: {e}")

        # Build result
        self._result = {
            "success": True,
            "output_file": self.output_file,
            "duration": self._total_elapsed,
            "interval": self.interval_seconds,
            "sample_count": self._sample_count,
            "actor_count": len(self._actor_refs),
            "actors_not_found": self._actors_not_found,
        }

        # Stop PIE if requested
        if self.auto_stop_pie:
            _stop_pie_session()

        # Stop tracer
        self.stop()

        # Mark as complete
        self._is_complete = True

        unreal.log(f"[OK] PIE tracing completed - {self._sample_count} samples in {self._total_elapsed:.1f}s")

        # Write completion file for MCP server to detect
        if self.task_id:
            project_dir = unreal.Paths.project_dir()
            completion_file = os.path.join(project_dir, "Saved", "Logs", f"{self.task_id}_completed")
            with open(completion_file, "w", encoding="utf-8") as f:
                json.dump(self._result, f)
            unreal.log(f"[OK] Wrote completion file: {completion_file}")

    @property
    def is_complete(self):
        """Check if tracing has completed (duration reached or manually stopped)."""
        return self._is_complete

    def get_result(self):
        """
        Get the trace result.

        Returns:
            dict with success, output_file, duration, interval, sample_count, actor_count, actors_not_found
            or None if not complete
        """
        return self._result


# ============================================
# MODULE-LEVEL FUNCTIONS
# ============================================

# Global instance
_tracer_instance = None


def start_pie_tracer(
    output_file,
    actor_names,
    interval_seconds=0.1,
    auto_start_pie=False,
    duration=None,
    auto_stop_pie=True,
    task_id=None,
    tick_callbacks=None
):
    """
    Start PIE actor tracer.

    Args:
        output_file: JSON output file path
        actor_names: List of actor names to track
        interval_seconds: Sampling interval in seconds
        auto_start_pie: Whether to auto-start PIE
        duration: Auto-stop after this many seconds
        auto_stop_pie: Whether to stop PIE when duration reached
        task_id: Unique task identifier for completion file
        tick_callbacks: Dict mapping sample numbers to Python code strings to execute.
                       Example: {0: "print('First sample')", 5: "custom_code()"}

    Returns:
        PIETracer instance
    """
    global _tracer_instance

    if _tracer_instance is not None:
        _tracer_instance.stop()

    _tracer_instance = PIETracer(
        output_file=output_file,
        actor_names=actor_names,
        interval_seconds=interval_seconds,
        duration=duration,
        auto_stop_pie=auto_stop_pie,
        task_id=task_id,
        tick_callbacks=tick_callbacks
    )
    _tracer_instance.start()

    # Auto-start PIE if requested
    if auto_start_pie:
        _start_pie_session()

    return _tracer_instance


def stop_pie_tracer():
    """Stop PIE actor tracer."""
    global _tracer_instance
    if _tracer_instance is not None:
        _tracer_instance.stop()
        _tracer_instance = None


def get_pie_tracer():
    """Get current tracer instance."""
    return _tracer_instance
