# editor_capture/pie_capture.py
# PIE (Play In Editor) screenshot capture for UE5
#
# Auto-captures screenshots during PIE runtime using tick callbacks,
# with multi-angle support for capturing the player character from
# multiple viewpoints.
#
# Usage:
#   from editor_capture import pie_capture
#
#   # Start capturer and auto-start PIE (default: screenshot every 1 second, multi-angle mode)
#   capturer = pie_capture.start_pie_capture(auto_start_pie=True)
#
#   # Single angle mode
#   capturer = pie_capture.start_pie_capture(auto_start_pie=True, multi_angle=False)
#
#   # Custom multi-angle parameters
#   capturer = pie_capture.start_pie_capture(
#       output_dir="C:/Screenshots",
#       interval_seconds=2.0,
#       resolution=(1920, 1080),
#       auto_start_pie=True,
#       multi_angle=True,
#       camera_distance=400,
#       target_height=90
#   )
#
#   # Stop capturer
#   pie_capture.stop_pie_capture()
#
#   # PIE session controls
#   pie_capture.start_pie_session()
#   pie_capture.stop_pie_session()
#   pie_capture.is_pie_running()

import unreal
import os
import json
from datetime import datetime


# ============================================
# VIEW CONFIGURATIONS
# ============================================

PIE_CAPTURE_VIEWS = [
    {"name": "front", "display_name": "Front View"},
    {"name": "side", "display_name": "Side View"},
    {"name": "top", "display_name": "Top View"},
    {"name": "perspective", "display_name": "45-Degree Perspective"},
]


# ============================================
# INTERNAL HELPERS
# ============================================


def _get_level_editor_subsystem():
    """
    Get the LevelEditorSubsystem.

    Returns:
        tuple: (subsystem, error_message) - subsystem is None if failed
    """
    subsystem = unreal.get_editor_subsystem(unreal.LevelEditorSubsystem)
    if not subsystem:
        return None, "Failed to get LevelEditorSubsystem"
    return subsystem, None


def _get_actor_subsystem():
    """
    Get the EditorActorSubsystem.

    Returns:
        tuple: (subsystem, error_message) - subsystem is None if failed
    """
    subsystem = unreal.get_editor_subsystem(unreal.EditorActorSubsystem)
    if not subsystem:
        return None, "Failed to get EditorActorSubsystem"
    return subsystem, None


def _ensure_output_directory(path):
    """
    Ensure output directory exists, creating it if necessary.

    Args:
        path: Directory path to ensure exists
    """
    if not os.path.exists(path):
        os.makedirs(path)
        unreal.log(f"[INFO] Created output directory: {path}")


def _calculate_pie_camera_transform(target, view_config, camera_distance, target_height):
    """
    Calculate camera position and rotation for PIE capture based on view configuration.

    Uses offset calculations to position camera, then uses find_look_at_rotation to
    calculate correct rotation automatically.

    Args:
        target: Target location (unreal.Vector) - already includes target_height offset
        view_config: View configuration dict from PIE_CAPTURE_VIEWS
        camera_distance: Base distance from target
        target_height: Height offset for target

    Returns:
        tuple: (camera_location, camera_rotation)
    """
    name = view_config["name"]
    distance_multiplier = view_config.get("distance_multiplier", 1.0)

    d = camera_distance * distance_multiplier
    h = target_height

    # Calculate offset based on view name
    # Character faces +X direction by default in UE5
    if name == "front":
        # Camera in front of character (X+), looking at character's face
        offset = (d, 0, h)
    elif name == "side":
        # Camera to the right side of character (Y+), looking at character's left side
        offset = (0, d, h)
    elif name == "top":
        # lambda d, _h: (0, 0, d) - camera directly above
        offset = (0, 0, d)
    elif name == "perspective":
        # 45-degree diagonal view from above (X+, Y+, elevated)
        # Use consistent height offset with other views but add elevation for perspective
        offset = (d * 0.707, d * 0.707, h + d * 0.5)
    else:
        # Fallback for custom views - use simple offset based on distance
        offset = (0, d, h)

    # Calculate camera position
    # Subtract target_height from Z since it's already added to target
    cam_x = target.x + offset[0]
    cam_y = target.y + offset[1]
    cam_z = target.z + offset[2] - target_height

    camera_location = unreal.Vector(cam_x, cam_y, cam_z)

    # Use UE5's find_look_at_rotation to calculate correct rotation
    # This automatically calculates the rotation needed to look from camera to target
    camera_rotation = unreal.MathLibrary.find_look_at_rotation(camera_location, target)

    return camera_location, camera_rotation


# ============================================
# PIE CAPTURER CLASS
# ============================================


class PIECapturer:
    """PIE screenshot capturer using tick callbacks, with multi-angle support."""

    def __init__(
        self,
        output_dir=None,
        interval_seconds=1.0,
        resolution=(1920, 1080),
        multi_angle=True,
        camera_distance=300,
        target_height=90,
        target_actor=None,
        views=None,
        duration=None,
        auto_stop_pie=True,
        task_id=None,
    ):
        """
        Initialize the PIE capturer.

        Args:
            output_dir: Screenshot output directory, defaults to project Screenshots/PIE_Captures
            interval_seconds: Screenshot interval in seconds
            resolution: Screenshot resolution (width, height)
            multi_angle: Enable multi-angle capture (4 angles)
            camera_distance: Camera distance from target
            target_height: Target height offset (from ground)
            target_actor: Name of the actor to capture (actor label or object name).
                         If None, captures around player character.
                         If specified but not found, capture fails with error.
            views: Custom view configurations (defaults to PIE_CAPTURE_VIEWS)
            duration: Auto-stop after this many seconds (None = run indefinitely)
            auto_stop_pie: Whether to stop PIE session when duration is reached
            task_id: Unique task identifier for completion file (used by MCP server)
        """
        # Set output directory
        if output_dir is None:
            project_dir = unreal.Paths.project_dir()
            output_dir = os.path.join(project_dir, "Screenshots", "PIE_Captures")

        self.output_dir = output_dir
        self.interval_seconds = interval_seconds
        self.resolution = resolution
        self.multi_angle = multi_angle
        self.camera_distance = camera_distance
        self.target_height = target_height
        self.target_actor = target_actor
        self.views = views if views is not None else PIE_CAPTURE_VIEWS
        self.duration = duration
        self.auto_stop_pie = auto_stop_pie
        self.task_id = task_id

        # State variables
        self._tick_handle = None
        self._pie_begin_handle = None
        self._pie_end_handle = None
        self._accumulated_time = 0.0
        self._screenshot_count = 0
        self._is_running = False
        self._pending_task = None
        self._is_in_pie = False
        self._camera_actor = None

        # Multi-angle state machine
        self._current_angle_index = 0
        self._capture_in_progress = False
        self._capture_timestamp = ""
        self._capture_base_count = 0
        self._capture_target = None

        # Duration tracking and completion state
        self._total_elapsed = 0.0
        self._is_complete = False
        self._result = None

        # Ensure output directory exists
        _ensure_output_directory(self.output_dir)

    def start(self):
        """Start the capturer."""
        if self._is_running:
            unreal.log_warning("[WARNING] PIE capturer already running")
            return

        self._is_running = True
        self._accumulated_time = 0.0
        self._screenshot_count = 0
        self._is_in_pie = False
        self._pending_task = None
        self._current_angle_index = 0
        self._capture_in_progress = False
        self._total_elapsed = 0.0
        self._is_complete = False
        self._result = None

        # Bind PIE lifecycle events
        editor_utility = unreal.get_editor_subsystem(unreal.EditorUtilitySubsystem)
        if editor_utility:
            self._pie_begin_handle = editor_utility.on_begin_pie.add_callable(self._on_pie_started)
            self._pie_end_handle = editor_utility.on_end_pie.add_callable(self._on_pie_ended)
        else:
            unreal.log_error("[ERROR] Failed to get EditorUtilitySubsystem for PIE events")
            self._is_running = False
            return

        # Check if PIE is already running
        pie_worlds = unreal.EditorLevelLibrary.get_pie_worlds(False)
        pie_already_running = len(pie_worlds) > 0

        # Pre-create camera for multi-angle mode (must be done BEFORE PIE starts)
        # If PIE is already running, camera spawn will fail and we'll fallback to single-angle
        if self.multi_angle and not pie_already_running:
            self._create_camera()
            if self._camera_actor is None:
                unreal.log_warning(
                    "[WARNING] Failed to create camera, falling back to single-angle mode"
                )
                self.multi_angle = False

        # Handle late start if PIE already running
        if pie_already_running:
            unreal.log("[INFO] PIE already running, starting capture immediately")
            if self.multi_angle and self._camera_actor is None:
                unreal.log_warning(
                    "[WARNING] Cannot create camera during PIE, using single-angle mode"
                )
                self.multi_angle = False
            self._on_pie_started(False)

        mode_str = f"Multi-angle ({len(self.views)} views)" if self.multi_angle else "Single view"
        unreal.log(f"[OK] PIE capturer started - Mode: {mode_str}")
        unreal.log(f"[INFO] Interval: {self.interval_seconds}s, Resolution: {self.resolution}")
        if self.multi_angle:
            unreal.log(
                f"[INFO] Camera distance: {self.camera_distance}, Target height: {self.target_height}"
            )
        unreal.log(f"[INFO] Output: {self.output_dir}")

    def stop(self):
        """Stop the capturer."""
        if not self._is_running:
            unreal.log_warning("[WARNING] PIE capturer not running")
            return

        self._is_running = False

        # Unbind PIE lifecycle events
        editor_utility = unreal.get_editor_subsystem(unreal.EditorUtilitySubsystem)
        if editor_utility:
            if self._pie_begin_handle is not None:
                editor_utility.on_begin_pie.remove_callable(self._pie_begin_handle)
                self._pie_begin_handle = None
            if self._pie_end_handle is not None:
                editor_utility.on_end_pie.remove_callable(self._pie_end_handle)
                self._pie_end_handle = None

        # Unregister tick callback
        if self._tick_handle is not None:
            unreal.unregister_slate_post_tick_callback(self._tick_handle)
            self._tick_handle = None

        # Destroy camera (check if still valid)
        if self._camera_actor is not None:
            try:
                if self._camera_actor.is_valid():
                    self._camera_actor.destroy_actor()
            except Exception:
                pass  # Camera already destroyed (e.g., when PIE ended)
            self._camera_actor = None

        self._is_in_pie = False
        unreal.log(f"[OK] PIE capturer stopped - Total screenshots: {self._screenshot_count}")

    def _create_camera(self):
        """Create camera actor for multi-angle capture."""
        actor_subsystem, error = _get_actor_subsystem()
        if error:
            unreal.log_error(f"[ERROR] {error}")
            return

        self._camera_actor = actor_subsystem.spawn_actor_from_class(
            unreal.CameraActor, unreal.Vector(0, 0, 0), transient=True
        )
        if self._camera_actor:
            self._camera_actor.set_actor_label("PIE_Screenshot_Camera")
            unreal.log("[OK] Created screenshot camera")
        else:
            unreal.log_error("[ERROR] Failed to create camera actor")

    def _on_pie_started(self, is_simulating):
        """Called when PIE session starts."""
        if not self._is_running:
            return

        if self._is_in_pie:
            return  # Already in PIE

        self._is_in_pie = True
        self._accumulated_time = 0.0
        self._capture_in_progress = False

        # Camera should already be created in start() before PIE began
        # If multi_angle is True but camera is None, fallback was already applied

        # Register tick callback
        if self._tick_handle is None:
            self._tick_handle = unreal.register_slate_post_tick_callback(self._on_tick)

        unreal.log("[INFO] PIE started - beginning capture")

    def _on_pie_ended(self, is_simulating):
        """Called when PIE session ends."""
        if not self._is_running:
            return

        if not self._is_in_pie:
            return  # Not in PIE

        self._is_in_pie = False
        self._capture_in_progress = False

        # Unregister tick callback
        if self._tick_handle is not None:
            unreal.unregister_slate_post_tick_callback(self._tick_handle)
            self._tick_handle = None

        # Destroy camera (it becomes invalid when PIE ends anyway)
        if self._camera_actor is not None:
            try:
                if self._camera_actor.is_valid():
                    self._camera_actor.destroy_actor()
            except Exception:
                pass  # Camera already destroyed
            self._camera_actor = None

        unreal.log("[INFO] PIE ended - pausing capture")

    def _find_target_actor(self, pie_world):
        """
        Find target actor by name in PIE world using fuzzy matching.

        Matching priority (stops at first match level):
        1. Exact match on object name (actor.get_name())
        2. Exact match on label (actor.get_actor_label())
        3. Exact match on class name (actor.get_class().get_name())
        4. Partial match on object name (contains)
        5. Partial match on label (contains)
        6. Partial match on class name (contains)

        Returns:
            tuple: (actor, available_actors_list, error_message)
            - actor: Found actor or None
            - available_actors_list: List of dicts with label/name/type for error reporting
            - error_message: Error message if multiple matches found, None otherwise
        """
        all_actors = unreal.GameplayStatics.get_all_actors_of_class(pie_world, unreal.Actor)
        available_actors = []

        # Build lookup tables for efficient matching
        actors_by_name = {}  # object name (lower) -> actor
        actors_by_label = {}  # label (lower) -> actor
        actors_by_class = {}  # class name (lower) -> [actors]

        for actor in all_actors:
            actor_name = actor.get_name()
            actor_label = actor.get_actor_label()
            actor_class = actor.get_class().get_name()

            # Collect actor info for error reporting
            available_actors.append({"label": actor_label, "name": actor_name, "type": actor_class})

            # Build lookup tables (lowercase for case-insensitive matching)
            name_lower = actor_name.lower()
            label_lower = actor_label.lower()
            class_lower = actor_class.lower()

            actors_by_name[name_lower] = actor
            actors_by_label[label_lower] = actor
            if class_lower not in actors_by_class:
                actors_by_class[class_lower] = []
            actors_by_class[class_lower].append(actor)

        if not self.target_actor:
            return None, available_actors, None

        target_lower = self.target_actor.lower()

        # 1. Exact match on object name
        if target_lower in actors_by_name:
            actor = actors_by_name[target_lower]
            unreal.log(f"[INFO] Matched by name (exact): {actor.get_name()}")
            return actor, available_actors, None

        # 2. Exact match on label
        if target_lower in actors_by_label:
            actor = actors_by_label[target_lower]
            unreal.log(f"[INFO] Matched by label (exact): {actor.get_actor_label()}")
            return actor, available_actors, None

        # 3. Exact match on class name
        if target_lower in actors_by_class:
            actors = actors_by_class[target_lower]
            if len(actors) > 1:
                matched_info = [
                    {
                        "label": a.get_actor_label(),
                        "name": a.get_name(),
                        "type": a.get_class().get_name(),
                    }
                    for a in actors
                ]
                error_msg = f"Multiple actors ({len(actors)}) match class '{self.target_actor}'"
                return None, matched_info, error_msg
            unreal.log(f"[INFO] Matched by class (exact): {actors[0].get_class().get_name()}")
            return actors[0], available_actors, None

        # 4. Partial match on object name (contains)
        # Only match when target is contained in name, not when name is contained in target
        partial_name_matches = []
        for name, actor in actors_by_name.items():
            if target_lower in name:
                partial_name_matches.append(actor)
        if partial_name_matches:
            if len(partial_name_matches) > 1:
                matched_info = [
                    {
                        "label": a.get_actor_label(),
                        "name": a.get_name(),
                        "type": a.get_class().get_name(),
                    }
                    for a in partial_name_matches
                ]
                error_msg = f"Multiple actors ({len(partial_name_matches)}) partially match name '{self.target_actor}'"
                return None, matched_info, error_msg
            actor = partial_name_matches[0]
            unreal.log(f"[INFO] Matched by name (partial): {actor.get_name()}")
            return actor, available_actors, None

        # 5. Partial match on label (contains)
        # Only match when target is contained in label, not when label is contained in target
        partial_label_matches = []
        for label, actor in actors_by_label.items():
            if target_lower in label:
                partial_label_matches.append(actor)
        if partial_label_matches:
            if len(partial_label_matches) > 1:
                matched_info = [
                    {
                        "label": a.get_actor_label(),
                        "name": a.get_name(),
                        "type": a.get_class().get_name(),
                    }
                    for a in partial_label_matches
                ]
                error_msg = f"Multiple actors ({len(partial_label_matches)}) partially match label '{self.target_actor}'"
                return None, matched_info, error_msg
            actor = partial_label_matches[0]
            unreal.log(f"[INFO] Matched by label (partial): {actor.get_actor_label()}")
            return actor, available_actors, None

        # 6. Partial match on class name (contains)
        # Only match when target is contained in class name, not when class name is contained in target
        partial_class_matches = []
        for class_name, actors in actors_by_class.items():
            if target_lower in class_name:
                partial_class_matches.extend(actors)
        if partial_class_matches:
            if len(partial_class_matches) > 1:
                matched_info = [
                    {
                        "label": a.get_actor_label(),
                        "name": a.get_name(),
                        "type": a.get_class().get_name(),
                    }
                    for a in partial_class_matches
                ]
                error_msg = f"Multiple actors ({len(partial_class_matches)}) partially match class '{self.target_actor}'"
                return None, matched_info, error_msg
            actor = partial_class_matches[0]
            unreal.log(f"[INFO] Matched by class (partial): {actor.get_class().get_name()}")
            return actor, available_actors, None

        # No match found
        return None, available_actors, None

    def _get_target_location(self, pie_world):
        """
        Get target location for capture.

        Returns:
            tuple: (location, error)
            - location: unreal.Vector or None if error
            - error: dict with 'message' and 'available_actors' or None if success
        """
        unreal.log(f"[DEBUG] _get_target_location called, target_actor='{self.target_actor}'")
        # If target_actor specified, find it (error if not found or multiple matches)
        if self.target_actor:
            actor, actors_list, error_msg = self._find_target_actor(pie_world)
            if actor:
                loc = actor.get_actor_location()
                unreal.log(
                    f"[INFO] Found target actor: {self.target_actor} -> {actor.get_actor_label()}"
                )
                return unreal.Vector(loc.x, loc.y, loc.z + self.target_height), None
            elif error_msg:
                # Multiple matches found - return error with matched actors
                error = {"message": error_msg, "matched_actors": actors_list}
                return None, error
            else:
                # Not found - return error with all available actors
                unreal.log(f"[DEBUG] Target actor '{self.target_actor}' not found, returning error")
                error = {
                    "message": f"Target actor '{self.target_actor}' not found",
                    "available_actors": actors_list,
                }
                return None, error

        # Default: player character/pawn
        player_char = unreal.GameplayStatics.get_player_character(pie_world, 0)
        if player_char:
            loc = player_char.get_actor_location()
            return unreal.Vector(loc.x, loc.y, loc.z + self.target_height), None

        player_pawn = unreal.GameplayStatics.get_player_pawn(pie_world, 0)
        if player_pawn:
            loc = player_pawn.get_actor_location()
            return unreal.Vector(loc.x, loc.y, loc.z + self.target_height), None

        # Default position
        return unreal.Vector(0, 0, self.target_height), None

    def _on_tick(self, delta_time):
        """Tick callback function - only called when PIE is running."""
        if not self._is_running or not self._is_in_pie:
            return

        # Track total elapsed time for duration check
        self._total_elapsed += delta_time

        # Check if duration reached - auto stop
        if self.duration is not None and self._total_elapsed >= self.duration:
            self._auto_complete()
            return

        # Check for pending screenshot task
        if self._pending_task is not None:
            if self._pending_task.is_task_done():
                self._pending_task = None
                # If multi-angle capture in progress, continue to next angle
                if self._capture_in_progress:
                    self._take_next_angle()
                    return
            else:
                # Task not complete, skip this tick
                return

        # If multi-angle capture in progress, don't accumulate time
        if self._capture_in_progress:
            return

        # Accumulate time for interval
        self._accumulated_time += delta_time

        # Check if screenshot interval reached
        if self._accumulated_time >= self.interval_seconds:
            self._accumulated_time = 0.0

            # Get PIE world
            pie_worlds = unreal.EditorLevelLibrary.get_pie_worlds(False)
            if len(pie_worlds) == 0:
                return  # PIE ended between event and tick

            pie_world = pie_worlds[0]

            if self.multi_angle:
                self._start_multi_angle_capture(pie_world)
            else:
                self._take_single_screenshot()

    def _take_single_screenshot(self):
        """Take single-angle screenshot."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = os.path.join(
            self.output_dir, f"PIE_Screenshot_{timestamp}_{self._screenshot_count:04d}.png"
        )

        unreal.AutomationLibrary.finish_loading_before_screenshot()

        self._pending_task = unreal.AutomationLibrary.take_high_res_screenshot(
            res_x=self.resolution[0],
            res_y=self.resolution[1],
            filename=filename,
            camera=None,
            mask_enabled=False,
            capture_hdr=False,
            comparison_tolerance=unreal.ComparisonTolerance.LOW,
            comparison_notes="",
            delay=0.0,
            force_game_view=True,
        )

        self._screenshot_count += 1
        unreal.log(f"[OK] Screenshot #{self._screenshot_count}: {os.path.basename(filename)}")

    def _start_multi_angle_capture(self, pie_world):
        """Start multi-angle capture sequence."""
        if self._camera_actor is None:
            unreal.log_error("[ERROR] Camera not available for multi-angle capture")
            self._take_single_screenshot()
            return

        # Get target location (may return error if target_actor not found)
        target, error = self._get_target_location(pie_world)
        if error:
            # Target actor not found - fail with error
            self._fail_with_error(error)
            return

        # Initialize multi-angle capture state
        self._capture_in_progress = True
        self._current_angle_index = 0
        self._capture_timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self._capture_base_count = self._screenshot_count
        self._capture_target = target

        unreal.log(
            f"[INFO] Starting multi-angle capture at target: ({self._capture_target.x:.0f}, {self._capture_target.y:.0f}, {self._capture_target.z:.0f})"
        )

        # Capture first angle
        self._take_current_angle()

    def _take_current_angle(self):
        """Capture current angle."""
        if self._current_angle_index >= len(self.views):
            # All angles captured
            self._capture_in_progress = False
            self._screenshot_count += 1
            unreal.log(f"[OK] Completed set #{self._screenshot_count} ({len(self.views)} angles)")
            return

        view_config = self.views[self._current_angle_index]

        # Calculate camera position and rotation
        cam_pos, cam_rot = _calculate_pie_camera_transform(
            self._capture_target, view_config, self.camera_distance, self.target_height
        )

        # Move camera
        self._camera_actor.set_actor_location_and_rotation(
            cam_pos, cam_rot, sweep=False, teleport=True
        )

        # Generate filename
        filename = os.path.join(
            self.output_dir,
            f"PIE_Screenshot_{self._capture_timestamp}_{self._capture_base_count:04d}_{view_config['name']}.png",
        )

        unreal.AutomationLibrary.finish_loading_before_screenshot()

        # Take screenshot
        self._pending_task = unreal.AutomationLibrary.take_high_res_screenshot(
            res_x=self.resolution[0],
            res_y=self.resolution[1],
            filename=filename,
            camera=self._camera_actor,
            mask_enabled=False,
            capture_hdr=False,
            comparison_tolerance=unreal.ComparisonTolerance.LOW,
            comparison_notes="",
            delay=0.0,
            force_game_view=True,
        )

        unreal.log(f"[OK] Screenshot {view_config['name']}: {os.path.basename(filename)}")

    def _take_next_angle(self):
        """Capture next angle."""
        self._current_angle_index += 1
        self._take_current_angle()

    def _auto_complete(self):
        """Auto-complete when duration is reached (called from tick callback)."""
        if self._is_complete:
            return  # Already completed

        unreal.log(f"[INFO] Duration ({self.duration}s) reached, auto-stopping...")

        # Build result before stopping
        self._result = {
            "success": True,
            "output_dir": self.output_dir,
            "duration": self._total_elapsed,
            "interval": self.interval_seconds,
            "screenshot_count": self._screenshot_count,
        }

        # Stop PIE if requested
        if self.auto_stop_pie:
            stop_pie_session()

        # Stop capturer
        self.stop()

        # Mark as complete
        self._is_complete = True

        unreal.log(
            f"[OK] PIE capture completed - {self._screenshot_count} screenshots in {self._total_elapsed:.1f}s"
        )

        # Write completion file for MCP server to detect
        if self.task_id:
            project_dir = unreal.Paths.project_dir()
            completion_file = os.path.join(
                project_dir, "Saved", "Logs", f"{self.task_id}_completed"
            )
            with open(completion_file, "w", encoding="utf-8") as f:
                json.dump(self._result, f)
            unreal.log(f"[OK] Wrote completion file: {completion_file}")

    def _fail_with_error(self, error):
        """Fail capture and write error to completion file."""
        self._result = {
            "success": False,
            "error": error["message"],
        }
        # Handle both available_actors (not found) and matched_actors (multiple matches)
        if "available_actors" in error:
            self._result["available_actors"] = error["available_actors"]
        if "matched_actors" in error:
            self._result["matched_actors"] = error["matched_actors"]

        self._is_complete = True

        unreal.log_error(f"[ERROR] {error['message']}")

        # Stop PIE
        if self.auto_stop_pie:
            stop_pie_session()

        # Stop capturer
        self.stop()

        # Write completion file with error
        if self.task_id:
            project_dir = unreal.Paths.project_dir()
            completion_file = os.path.join(
                project_dir, "Saved", "Logs", f"{self.task_id}_completed"
            )
            with open(completion_file, "w", encoding="utf-8") as f:
                json.dump(self._result, f)
            unreal.log(f"[OK] Wrote completion file: {completion_file}")

    @property
    def is_complete(self):
        """Check if capture has completed (duration reached or manually stopped)."""
        return self._is_complete

    def get_result(self):
        """
        Get the capture result.

        Returns:
            dict with success, output_dir, duration, interval, screenshot_count
            or None if not complete
        """
        return self._result


# ============================================
# MODULE-LEVEL FUNCTIONS
# ============================================

# Global instance
_capturer_instance = None


def start_pie_capture(
    output_dir=None,
    interval_seconds=1.0,
    resolution=(1920, 1080),
    auto_start_pie=False,
    multi_angle=True,
    camera_distance=300,
    target_height=90,
    target_actor=None,
    views=None,
    duration=None,
    auto_stop_pie=True,
    task_id=None,
):
    """
    Start PIE screenshot capturer.

    Args:
        output_dir: Screenshot output directory
        interval_seconds: Screenshot interval in seconds
        resolution: Screenshot resolution (width, height)
        auto_start_pie: Whether to auto-start PIE
        multi_angle: Enable multi-angle capture (4 angles: front, side, top, 45-degree perspective)
        camera_distance: Camera distance from target
        target_height: Target height offset
        target_actor: Name of actor to capture (actor label or object name).
                     If None, captures around player. If specified but not found, fails with error.
        views: Custom view configurations (defaults to PIE_CAPTURE_VIEWS)
        duration: Auto-stop after this many seconds (None = run indefinitely)
        auto_stop_pie: Whether to stop PIE session when duration is reached
        task_id: Unique task identifier for completion file (used by MCP server)

    Returns:
        PIECapturer instance
    """
    global _capturer_instance

    if _capturer_instance is not None:
        _capturer_instance.stop()

    _capturer_instance = PIECapturer(
        output_dir=output_dir,
        interval_seconds=interval_seconds,
        resolution=resolution,
        multi_angle=multi_angle,
        camera_distance=camera_distance,
        target_height=target_height,
        target_actor=target_actor,
        views=views,
        duration=duration,
        auto_stop_pie=auto_stop_pie,
        task_id=task_id,
    )
    _capturer_instance.start()

    # Auto-start PIE if requested
    if auto_start_pie:
        start_pie_session()

    return _capturer_instance


def stop_pie_capture():
    """Stop PIE screenshot capturer."""
    global _capturer_instance

    if _capturer_instance is not None:
        _capturer_instance.stop()
        _capturer_instance = None


def get_pie_capturer():
    """Get current capturer instance."""
    return _capturer_instance


def start_pie_session():
    """Start PIE (Play In Editor) session."""
    subsystem, error = _get_level_editor_subsystem()
    if error:
        unreal.log_error(f"[ERROR] {error}")
        return False

    if subsystem.is_in_play_in_editor():
        unreal.log_warning("[WARNING] PIE is already running")
        return False

    subsystem.editor_request_begin_play()
    unreal.log("[OK] PIE start requested")
    return True


def stop_pie_session():
    """Stop PIE (Play In Editor) session."""
    subsystem, error = _get_level_editor_subsystem()
    if error:
        unreal.log_error(f"[ERROR] {error}")
        return False

    if not subsystem.is_in_play_in_editor():
        unreal.log_warning("[WARNING] PIE is not running")
        return False

    subsystem.editor_request_end_play()
    unreal.log("[OK] PIE stop requested")
    return True


def is_pie_running():
    """Check if PIE is currently running."""
    subsystem, error = _get_level_editor_subsystem()
    if error:
        return False
    return subsystem.is_in_play_in_editor()


# If running this script directly, start capturer and auto-start PIE (multi-angle mode)
if __name__ == "__main__":
    start_pie_capture(auto_start_pie=True, multi_angle=True)
