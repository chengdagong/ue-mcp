# PIE (Play In Editor) actor transform tracing for UE5
#
# Traces specified actors' transforms (location, rotation, velocity) during PIE
# runtime using PIETickExecutor for tick-based execution.
#
# Optionally captures screenshots of tracked actors at each sample interval.

import unreal
import os
import json
import math
from datetime import datetime

from .pie_tick_executor import PIETickExecutor


# ============================================
# VIEW CONFIGURATIONS FOR SCREENSHOTS
# ============================================

PIE_TRACER_VIEWS = [
    {"name": "front", "display_name": "Front View"},
    {"name": "side", "display_name": "Side View"},
    {"name": "back", "display_name": "Back View"},
    {"name": "perspective", "display_name": "45-Degree Perspective"},
]


def _ensure_output_directory(path):
    """
    Ensure output directory exists, creating it if necessary.

    Args:
        path: File path to ensure parent directory exists
    """
    dir_path = os.path.dirname(path)
    if dir_path and not os.path.exists(dir_path):
        os.makedirs(dir_path)
        unreal.log(f"[INFO] Created output directory: {dir_path}")


def _ensure_directory(path):
    """
    Ensure directory exists, creating it if necessary.

    Args:
        path: Directory path to ensure exists
    """
    if not os.path.exists(path):
        os.makedirs(path)
        unreal.log(f"[INFO] Created directory: {path}")


# ============================================
# PIE TRACER CLASS
# ============================================


class PIETracer:
    """PIE actor transform tracer using PIETickExecutor with optional screenshot capture."""

    # Assumed FPS for time-to-tick conversion
    ASSUMED_FPS = 60

    def __init__(
        self,
        output_dir,
        actor_names,
        interval_seconds=0.1,
        duration=None,
        auto_stop_pie=True,
        task_id=None,
        tick_callbacks=None,
        # Screenshot capture options
        capture_screenshots=False,
        camera_distance=300,
        target_height=90,
        resolution=(800, 600),
        multi_angle=True,
        views=None,
    ):
        """
        Initialize the PIE tracer.

        Args:
            output_dir: Output directory for trace data (will contain actor subdirectories)
            actor_names: List of actor names to track
            interval_seconds: Sampling interval in seconds
            duration: Auto-stop after this many seconds (None = run indefinitely)
            auto_stop_pie: Whether to stop PIE session when duration is reached
            task_id: Unique task identifier for completion file (used by MCP server)
            tick_callbacks: Dict mapping sample numbers to Python code strings to execute.
                           Example: {0: "print('First sample')", 5: "custom_code()"}
                           Code is executed after sampling at the specified sample number.
            capture_screenshots: Whether to capture screenshots of actors (default: False)
            camera_distance: Camera distance from actor for screenshots (default: 300)
            target_height: Target height offset from actor origin (default: 90)
            resolution: Screenshot resolution as (width, height) tuple (default: (800, 600))
            multi_angle: Whether to capture multiple angles (default: True)
            views: Custom view configurations (defaults to PIE_TRACER_VIEWS)
        """
        self.output_dir = output_dir
        self.actor_names = actor_names
        self.interval_seconds = interval_seconds
        self.duration = duration
        self.auto_stop_pie = auto_stop_pie
        self.task_id = task_id
        self.tick_callbacks = tick_callbacks or {}

        # Screenshot capture settings
        self.capture_screenshots = capture_screenshots
        self.camera_distance = camera_distance
        self.target_height = target_height
        self.resolution = resolution
        self.multi_angle = multi_angle
        self.views = views if views is not None else PIE_TRACER_VIEWS

        # Internal executor
        self._executor = None

        # State variables
        self._accumulated_time = 0.0
        self._total_elapsed = 0.0
        self._sample_count = 0
        self._current_tick = 0  # Current tick number from executor
        self._is_running = False
        self._is_complete = False
        self._result = None

        # Actor tracking
        self._actor_refs = {}  # {name: actor_object}
        self._actor_labels = {}  # {name: actor_label} - for directory naming
        self._actors_not_found = []

        # Screenshot state (using SceneCapture2D for PIE world rendering)
        self._scene_capture_actor = None  # SceneCapture2D in EDITOR world
        self._pie_capture_actor = None  # SceneCapture2D duplicate in PIE world (lazy init)
        self._render_target = None  # TextureRenderTarget2D for rendering
        self._pie_world = None  # Reference to PIE world
        self._current_screenshot_queue = []  # [(actor_name, view_config, filename), ...]
        self._current_sample_screenshots = {}  # {actor_name: [screenshot_paths]}
        self._is_paused_for_screenshots = False  # Whether game is paused for screenshot capture

        # Metadata (will be written to metadata.json at the end)
        self._metadata = {
            "level": "",
            "start_time": "",
            "end_time": "",
            "duration": 0.0,
            "interval": interval_seconds,
            "sample_count": 0,
            "actors": [],
            "actors_not_found": [],
            "capture_screenshots": capture_screenshots,
        }

        # Ensure output directory exists
        _ensure_directory(self.output_dir)

    def start(self):
        """Start the tracer using PIETickExecutor."""
        if self._is_running:
            unreal.log_warning("[WARNING] PIE tracer already running")
            return

        self._is_running = True
        self._accumulated_time = 0.0
        self._total_elapsed = 0.0
        self._sample_count = 0
        self._current_tick = 0
        self._is_complete = False
        self._result = None
        self._actor_refs = {}
        self._actor_labels = {}
        self._actors_not_found = []

        # Reset screenshot state
        self._scene_capture_actor = None
        self._pie_capture_actor = None
        self._render_target = None
        self._pie_world = None
        self._current_screenshot_queue = []
        self._current_sample_screenshots = {}
        self._is_paused_for_screenshots = False

        # Initialize metadata
        self._metadata = {
            "level": "",
            "start_time": datetime.now().isoformat(),
            "end_time": "",
            "duration": 0.0,
            "interval": self.interval_seconds,
            "sample_count": 0,
            "actors": [],
            "actors_not_found": [],
            "capture_screenshots": self.capture_screenshots,
        }

        # Check if PIE already running - stop it and warn user
        pie_worlds = unreal.EditorLevelLibrary.get_pie_worlds(False)
        if len(pie_worlds) > 0:
            unreal.log_warning("[WARNING] PIE already running - stopping PIE to create SceneCapture2D")
            level_editor = unreal.get_editor_subsystem(unreal.LevelEditorSubsystem)
            level_editor.editor_set_game_view(False)
            # Brief wait for PIE to fully stop
            import time
            time.sleep(0.5)

        # Create SceneCapture2D in editor world if screenshots enabled
        # It will be automatically duplicated to PIE world when PIE starts
        if self.capture_screenshots:
            if not self._create_scene_capture():
                unreal.log_warning("[WARNING] Failed to create scene capture, disabling screenshots")
                self.capture_screenshots = False

        # Calculate total ticks
        if self.duration is not None:
            total_ticks = int(self.duration * self.ASSUMED_FPS) + 1
        else:
            # Run for a very long time if no duration specified
            total_ticks = 10 * 60 * self.ASSUMED_FPS  # 10 minutes max

        # Build the sampling code that will be executed each tick
        sample_code = self._build_sample_code()

        # Create and configure PIETickExecutor
        # We execute on every tick, but the sample code handles interval timing
        self._executor = PIETickExecutor(
            total_ticks=total_ticks,
            code_snippets=[
                {
                    "code": sample_code,
                    "start_tick": 0,
                    "execution_count": total_ticks,
                }
            ],
            auto_stop_pie=self.auto_stop_pie,  # Let executor handle PIE stop
            task_id=None,  # We write completion file ourselves
            on_before_complete=self._on_executor_complete,  # Save data before PIE stops
        )

        # Start the executor (this resets exec_context, so we inject after)
        self._executor.start()

        # Inject tracer context into executor AFTER start() which resets the context
        self._executor._exec_context.update(
            {
                "__tracer__": self,
            }
        )

        unreal.log(f"[OK] PIE tracer started - Tracking {len(self.actor_names)} actors")
        unreal.log(f"[INFO] Interval: {self.interval_seconds}s, Output: {self.output_dir}")

    def _build_sample_code(self):
        """Build the sampling code to be executed each tick."""
        # This code will be executed every tick by PIETickExecutor
        # It handles time accumulation, sampling, and screenshot capture internally
        return """
tracer = __tracer__
delta_time = 1.0 / 60.0  # Approximate delta time

# Update current tick from executor (use _tick_count attribute)
tracer._current_tick = __executor__._tick_count

# Track total elapsed time
tracer._total_elapsed += delta_time

# Process any pending screenshots first
if tracer._process_screenshot_queue():
    # Screenshots still in progress, skip other processing
    pass
elif tracer.duration is not None and tracer._total_elapsed >= tracer.duration:
    # Duration reached - trigger executor completion
    # This will call on_before_complete callback before stopping PIE
    __executor__._auto_complete()
else:
    # Accumulate time for interval
    tracer._accumulated_time += delta_time

    # Check if sample interval reached
    if tracer._accumulated_time >= tracer.interval_seconds:
        tracer._accumulated_time -= tracer.interval_seconds
        tracer._do_sample()
"""

    def _do_sample(self):
        """Perform a single sample of all tracked actors."""
        # Get PIE world
        pie_worlds = unreal.EditorLevelLibrary.get_pie_worlds(False)
        if len(pie_worlds) == 0:
            return  # PIE not running

        pie_world = pie_worlds[0]

        # Get level name on first sample
        if self._sample_count == 0:
            level_name = pie_world.get_name()
            self._metadata["level"] = level_name

        # Lazy actor discovery on first sample
        if not self._actor_refs and self._sample_count == 0:
            found_count = self._find_actors(pie_world)
            if found_count == 0:
                unreal.log_error("[ERROR] No actors found to track, stopping tracer")
                # Trigger executor completion to stop cleanly
                if self._executor:
                    self._executor._auto_complete()
                return

        # Get current tick for directory naming
        tick = self._current_tick

        # Prepare screenshot tracking for this sample
        self._current_sample_screenshots = {}

        # Sample each tracked actor and write transform.json
        for name, actor in self._actor_refs.items():
            try:
                # Get actor label for directory naming
                actor_label = self._actor_labels.get(name, name)
                safe_label = self._sanitize_dirname(actor_label)

                # Create sample directory: output_dir/{actor_label}/sample_at_tick_{tick}/
                sample_dir = os.path.join(self.output_dir, safe_label, f"sample_at_tick_{tick}")
                _ensure_directory(sample_dir)

                # Sample transform data
                sample_data = self._sample_actor(actor, self._total_elapsed, tick)

                # Create screenshots directory if capturing
                if self.capture_screenshots:
                    screenshots_dir = os.path.join(sample_dir, "screenshots")
                    _ensure_directory(screenshots_dir)

                # Write transform.json immediately
                transform_file = os.path.join(sample_dir, "transform.json")
                with open(transform_file, "w", encoding="utf-8") as f:
                    json.dump(sample_data, f, indent=2)

                # Store sample directory for screenshot capture
                self._current_sample_screenshots[name] = {
                    "sample_dir": sample_dir,
                    "screenshots": [],
                }

            except (RuntimeError, ReferenceError):
                # Actor was destroyed during PIE
                unreal.log_warning(f"[WARNING] Actor '{name}' is no longer valid, skipping")
                continue

        self._sample_count += 1

        # Start screenshot capture if enabled
        # (SceneCapture2D will be created lazily on first use)
        if self.capture_screenshots:
            self._start_screenshot_capture()

            # Pause the game while capturing screenshots
            # This ensures screenshots are taken at the exact moment of transform sampling
            if self._current_screenshot_queue:
                self._pause_game(True)

        # Execute tick callback if registered for this sample number
        self._execute_tick_callback(self._sample_count - 1)

    def _sanitize_dirname(self, name):
        """
        Sanitize a string for use as a directory name.

        Args:
            name: String to sanitize

        Returns:
            Sanitized string safe for directory names
        """
        # Replace problematic characters
        safe = name.replace(" ", "_").replace("/", "_").replace("\\", "_")
        safe = safe.replace(":", "_").replace("*", "_").replace("?", "_")
        safe = safe.replace('"', "_").replace("<", "_").replace(">", "_")
        safe = safe.replace("|", "_")
        return safe

    def stop(self):
        """Stop the tracer."""
        if not self._is_running:
            unreal.log_warning("[WARNING] PIE tracer not running")
            return

        self._is_running = False

        # Resume game if paused
        if self._is_paused_for_screenshots:
            self._pause_game(False)

        # Stop the executor
        if self._executor is not None:
            self._executor.stop()
            self._executor = None

        # Destroy camera if exists
        self._destroy_scene_capture()

        unreal.log(f"[OK] PIE tracer stopped - Total samples: {self._sample_count}")

    def _find_actors(self, pie_world):
        """
        Find actor references by name in PIE world using fuzzy matching.

        Matching priority (stops at first match):
        1. Exact match on object name (actor.get_name())
        2. Exact match on label (actor.get_actor_label())
        3. Exact match on class name (actor.get_class().get_name())
        4. Partial match on object name (contains)
        5. Partial match on label (contains)
        6. Partial match on class name (contains)

        Returns:
            Number of actors successfully found
        """
        all_actors = unreal.GameplayStatics.get_all_actors_of_class(pie_world, unreal.Actor)

        # Build lookup tables for efficient matching
        actors_by_name = {}  # object name -> actor
        actors_by_label = {}  # label -> actor
        actors_by_class = {}  # class name -> [actors]

        for actor in all_actors:
            obj_name = actor.get_name().lower()
            label = actor.get_actor_label().lower()
            class_name = actor.get_class().get_name().lower()

            actors_by_name[obj_name] = actor
            actors_by_label[label] = actor
            if class_name not in actors_by_class:
                actors_by_class[class_name] = []
            actors_by_class[class_name].append(actor)

        for target_name in self.actor_names:
            target_lower = target_name.lower()
            found_actor = None
            match_type = None

            # 1. Exact match on object name
            if target_lower in actors_by_name:
                found_actor = actors_by_name[target_lower]
                match_type = "name"

            # 2. Exact match on label
            if not found_actor and target_lower in actors_by_label:
                found_actor = actors_by_label[target_lower]
                match_type = "label"

            # 3. Exact match on class name
            if not found_actor and target_lower in actors_by_class:
                actors = actors_by_class[target_lower]
                if len(actors) > 1:
                    unreal.log_warning(
                        f"[WARNING] Multiple actors of class '{target_name}', using first"
                    )
                found_actor = actors[0]
                match_type = "class"

            # 4. Partial match on object name (contains)
            # Only match if target is a significant substring (at least 4 chars)
            # to avoid overly aggressive matching
            if not found_actor and len(target_lower) >= 4:
                for obj_name, actor in actors_by_name.items():
                    # Only allow partial match if target is fully contained in name
                    # Don't match if name is contained in target (too aggressive)
                    if target_lower in obj_name:
                        found_actor = actor
                        match_type = "name (partial)"
                        break

            # 5. Partial match on label (contains)
            if not found_actor and len(target_lower) >= 4:
                for label, actor in actors_by_label.items():
                    if target_lower in label:
                        found_actor = actor
                        match_type = "label (partial)"
                        break

            # 6. Partial match on class name (contains)
            if not found_actor and len(target_lower) >= 4:
                for class_name, actors in actors_by_class.items():
                    if target_lower in class_name:
                        if len(actors) > 1:
                            unreal.log_warning(
                                f"[WARNING] Multiple actors match class '{target_name}', using first"
                            )
                        found_actor = actors[0]
                        match_type = "class (partial)"
                        break

            if found_actor:
                self._actor_refs[target_name] = found_actor
                # Save actor label for directory naming (prefer label over name)
                actual_label = found_actor.get_actor_label()
                actual_name = found_actor.get_name()
                # Use label if not empty, otherwise use object name
                self._actor_labels[target_name] = actual_label if actual_label else actual_name
                actual_class = found_actor.get_class().get_name()
                unreal.log(
                    f"[OK] Found actor: {target_name} -> {actual_label} ({actual_class}) [matched by {match_type}]"
                )
            else:
                self._actors_not_found.append(target_name)
                unreal.log_warning(f"[WARNING] Actor not found: {target_name}")

        return len(self._actor_refs)

    def _sample_actor(self, actor, timestamp, tick):
        """
        Sample a single actor's transform data.

        Args:
            actor: Actor to sample
            timestamp: Current timestamp in seconds
            tick: Current tick number from executor

        Returns:
            dict with tick, timestamp, location, rotation, velocity, screenshots
        """
        # Get location
        loc = actor.get_actor_location()

        # Get rotation
        rot = actor.get_actor_rotation()

        # Get velocity (if available)
        velocity = None
        if hasattr(actor, "get_velocity"):
            try:
                vel = actor.get_velocity()
                if vel:  # Check not None
                    velocity = {"x": vel.x, "y": vel.y, "z": vel.z}
            except (AttributeError, RuntimeError):
                pass  # Actor doesn't support velocity

        return {
            "tick": tick,
            "timestamp": round(timestamp, 3),
            "location": {"x": round(loc.x, 2), "y": round(loc.y, 2), "z": round(loc.z, 2)},
            "rotation": {
                "pitch": round(rot.pitch, 2),
                "yaw": round(rot.yaw, 2),
                "roll": round(rot.roll, 2),
            },
            "velocity": velocity,
            "screenshots": [],  # Will be populated if screenshots are enabled
        }

    # ============================================
    # SCREENSHOT CAPTURE METHODS
    # ============================================

    def _create_scene_capture(self):
        """
        Create SceneCapture2D actor in EDITOR world.
        Will be automatically duplicated to PIE world when PIE starts.
        """
        # Get editor world (not PIE world)
        editor_world = unreal.EditorLevelLibrary.get_editor_world()
        if not editor_world:
            unreal.log_error("[ERROR] Failed to get editor world")
            return False

        # Use EditorActorSubsystem to create in editor world
        actor_subsystem = unreal.get_editor_subsystem(unreal.EditorActorSubsystem)
        if not actor_subsystem:
            unreal.log_error("[ERROR] Failed to get EditorActorSubsystem")
            return False

        # Create SceneCapture2D in editor world
        # NOTE: Do NOT use transient=True as it prevents duplication to PIE world
        self._scene_capture_actor = actor_subsystem.spawn_actor_from_class(
            unreal.SceneCapture2D,
            unreal.Vector(0, 0, 0)
        )

        if not self._scene_capture_actor:
            unreal.log_error("[ERROR] Failed to create SceneCapture2D actor")
            return False

        self._scene_capture_actor.set_actor_label("PIE_Tracer_SceneCapture")
        unreal.log(f"[OK] Created SceneCapture2D in editor world: {self._scene_capture_actor.get_name()}")

        # Create render target in editor world
        self._render_target = unreal.RenderingLibrary.create_render_target2d(
            editor_world,
            self.resolution[0],
            self.resolution[1],
            unreal.TextureRenderTargetFormat.RTF_RGBA8
        )

        if not self._render_target:
            unreal.log_error("[ERROR] Failed to create render target")
            return False

        # Configure capture component
        capture_component = self._scene_capture_actor.capture_component2d
        capture_component.texture_target = self._render_target
        capture_component.capture_source = unreal.SceneCaptureSource.SCS_FINAL_COLOR_LDR

        unreal.log("[OK] SceneCapture2D created (will be duplicated to PIE)")
        return True

    def _find_scene_capture_in_pie(self):
        """
        Find the PIE duplicate of our SceneCapture2D actor.

        When PIE starts, UE5 automatically duplicates all editor actors into PIE world.
        This should always succeed - if it doesn't, let the exception propagate.

        Returns:
            SceneCapture2D actor in PIE world
        """
        pie_worlds = unreal.EditorLevelLibrary.get_pie_worlds(False)
        self._pie_world = pie_worlds[0]

        # Find all SceneCapture2D actors in PIE world
        scene_captures = unreal.GameplayStatics.get_all_actors_of_class(
            self._pie_world,
            unreal.SceneCapture2D
        )

        # Find our actor by label
        for actor in scene_captures:
            if actor.get_actor_label() == "PIE_Tracer_SceneCapture":
                unreal.log(f"[OK] Found SceneCapture2D in PIE: {actor.get_name()}")
                return actor

        # This should never happen - if it does, raise an exception
        raise RuntimeError("SceneCapture2D duplicate not found in PIE world")

    def _destroy_scene_capture(self):
        """Destroy the SceneCapture2D actor and render target if they exist."""
        # Destroy editor world actor
        if self._scene_capture_actor is not None:
            try:
                if unreal.SystemLibrary.is_valid(self._scene_capture_actor):
                    self._scene_capture_actor.destroy_actor()
            except Exception:
                pass  # Actor already destroyed
            self._scene_capture_actor = None

        # PIE duplicate will be destroyed automatically when PIE ends
        self._pie_capture_actor = None
        self._render_target = None
        self._pie_world = None

    def _pause_game(self, paused):
        """
        Pause or resume the game during PIE.

        Args:
            paused: True to pause, False to resume
        """
        if paused == self._is_paused_for_screenshots:
            return  # Already in desired state

        pie_worlds = unreal.EditorLevelLibrary.get_pie_worlds(False)
        if len(pie_worlds) == 0:
            return

        pie_world = pie_worlds[0]

        try:
            # Use PIE world directly as world context
            unreal.GameplayStatics.set_game_paused(pie_world, paused)
            self._is_paused_for_screenshots = paused
            state = "paused" if paused else "resumed"
            unreal.log(f"[OK] Game {state} for screenshot capture")
        except Exception as e:
            unreal.log_error(f"[ERROR] Failed to {('pause' if paused else 'resume')} game: {e}")

    def _calculate_camera_transform(self, target_location, view_config):
        """
        Calculate camera position and rotation for a given view.

        Uses offset calculations for different view types to position camera,
        then uses find_look_at_rotation to calculate correct rotation automatically:
        - front/side/back: horizontal views with height offset
        - perspective: 45-degree diagonal view from above
        - top: directly above looking down

        Args:
            target_location: Target location (unreal.Vector)
            view_config: View configuration dict with name

        Returns:
            tuple: (camera_location, camera_rotation)
        """
        name = view_config["name"]
        distance_multiplier = view_config.get("distance_multiplier", 1.0)

        d = self.camera_distance * distance_multiplier
        h = self.target_height

        # Calculate offset based on view name
        # Character faces +X direction by default in UE5
        if name == "front":
            # Camera in front of character (X+), looking at character's face
            offset = (d, 0, h)
        elif name == "side":
            # Camera to the right side of character (Y+), looking at character's left side
            offset = (0, d, h)
        elif name == "back":
            # Camera behind character (X-), looking at character's back
            offset = (-d, 0, h)
        elif name == "top":
            # Camera directly above
            offset = (0, 0, d)
        elif name == "perspective":
            # 45-degree diagonal view from above (X+, Y+, elevated)
            # Use consistent height offset with other views but add elevation for perspective
            offset = (d * 0.707, d * 0.707, h + d * 0.5)
        else:
            # Fallback: use spherical coordinates for custom views if yaw/pitch provided
            yaw = view_config.get("yaw", 0)
            pitch = view_config.get("pitch", 0)
            yaw_rad = math.radians(yaw)
            pitch_rad = math.radians(pitch)
            horizontal_dist = d * math.cos(pitch_rad)
            vertical_offset = d * math.sin(-pitch_rad)
            offset = (
                horizontal_dist * math.cos(yaw_rad),
                horizontal_dist * math.sin(yaw_rad),
                vertical_offset + h,
            )

        # Calculate camera position
        camera_location = unreal.Vector(
            target_location.x + offset[0],
            target_location.y + offset[1],
            target_location.z + offset[2],
        )

        # Use UE5's find_look_at_rotation to calculate correct rotation
        # This automatically calculates the rotation needed to look from camera to target
        camera_rotation = unreal.MathLibrary.find_look_at_rotation(camera_location, target_location)

        return camera_location, camera_rotation

    def _start_screenshot_capture(self):
        """Start capturing screenshots for all tracked actors in current sample."""
        # On first screenshot capture, find PIE duplicate of our scene capture
        if self._pie_capture_actor is None:
            # Find PIE duplicate (lazy initialization on first use)
            # If this fails, let the exception propagate
            self._pie_capture_actor = self._find_scene_capture_in_pie()
            unreal.log("[OK] Using SceneCapture2D duplicate from PIE world")

        # Build the screenshot queue for this sample
        self._current_screenshot_queue = []
        tick = self._current_tick

        for actor_name, actor in self._actor_refs.items():
            try:
                if not unreal.SystemLibrary.is_valid(actor):
                    continue

                # Get sample info
                sample_info = self._current_sample_screenshots.get(actor_name)
                if not sample_info:
                    continue

                sample_dir = sample_info["sample_dir"]
                screenshots_dir = os.path.join(sample_dir, "screenshots")

                # Get views to capture
                if self.multi_angle:
                    views_to_capture = self.views
                else:
                    # Single angle: just front view
                    views_to_capture = [self.views[0]] if self.views else []

                for view_config in views_to_capture:
                    # Generate filename: {output_dir}/{actor_label}/sample_at_tick_{tick}/screenshots/{view}.png
                    view_name = view_config["name"]
                    filename = os.path.join(screenshots_dir, f"{view_name}.png")

                    # Queue this screenshot
                    self._current_screenshot_queue.append(
                        {
                            "actor_name": actor_name,
                            "actor": actor,
                            "view_config": view_config,
                            "filename": filename,
                            "sample_dir": sample_dir,
                        }
                    )

            except (RuntimeError, ReferenceError):
                continue

        # Start processing the queue
        if self._current_screenshot_queue:
            unreal.log(
                f"[INFO] Starting screenshot capture for tick #{tick} ({len(self._current_screenshot_queue)} shots)"
            )

    def _process_screenshot_queue(self):
        """
        Process pending screenshots in the queue.
        Since capture_scene() is synchronous, we process all screenshots immediately.

        Returns:
            True if there are still screenshots being processed, False otherwise
        """
        # Check if there are more screenshots to take
        if not self._current_screenshot_queue:
            # Queue empty - resume game if it was paused
            if self._is_paused_for_screenshots:
                self._pause_game(False)
            return False

        # Take next screenshot (synchronous operation)
        shot_info = self._current_screenshot_queue.pop(0)
        self._take_screenshot(shot_info)

        # Continue processing queue until empty
        return len(self._current_screenshot_queue) > 0

    def _take_screenshot(self, shot_info):
        """
        Take a single screenshot using SceneCapture2D in PIE world.

        Args:
            shot_info: Dict with actor_name, actor, view_config, filename, sample_dir
        """
        actor = shot_info["actor"]
        view_config = shot_info["view_config"]
        filename = shot_info["filename"]
        actor_name = shot_info["actor_name"]
        sample_dir = shot_info["sample_dir"]

        unreal.log(f"[DEBUG] Taking screenshot for {actor_name}, view={view_config['name']}")

        try:
            if not unreal.SystemLibrary.is_valid(actor):
                unreal.log_warning(
                    f"[WARNING] Actor {actor_name} no longer valid, skipping screenshot"
                )
                return

            if not self._pie_capture_actor or not self._render_target:
                unreal.log_error("[ERROR] SceneCapture2D or render target not available")
                return

            unreal.log(f"[DEBUG] Using PIE SceneCapture2D: {self._pie_capture_actor.get_name()}")

            # Get actor location
            target_location = actor.get_actor_location()
            unreal.log(f"[DEBUG] Target location: {target_location}")

            # Calculate camera transform
            cam_pos, cam_rot = self._calculate_camera_transform(target_location, view_config)

            # Move PIE SceneCapture2D actor (not editor actor)
            self._pie_capture_actor.set_actor_location_and_rotation(
                cam_pos, cam_rot, sweep=False, teleport=True
            )

            # Capture the scene using PIE actor
            capture_component = self._pie_capture_actor.capture_component2d
            capture_component.capture_scene()

            # Export render target to file
            # Note: export_render_target requires filename without extension
            output_dir = os.path.dirname(filename)
            screenshot_basename = os.path.splitext(os.path.basename(filename))[0]

            unreal.RenderingLibrary.export_render_target(
                self._pie_world,
                self._render_target,
                output_dir,
                screenshot_basename
            )

            # UE5 exports without .png extension, need to rename
            temp_path = os.path.join(output_dir, screenshot_basename)
            final_path = filename  # This should already have .png extension

            if os.path.exists(temp_path):
                if os.path.exists(final_path):
                    os.remove(final_path)
                os.rename(temp_path, final_path)
            elif not os.path.exists(final_path):
                unreal.log_warning(f"[WARNING] Screenshot file not created: {filename}")
                return

            # Record screenshot in sample info (just the view name, not full path)
            view_name = view_config["name"]
            sample_info = self._current_sample_screenshots.get(actor_name)
            if sample_info:
                sample_info["screenshots"].append(f"{view_name}.png")

                # Update transform.json with screenshot list
                transform_file = os.path.join(sample_dir, "transform.json")
                if os.path.exists(transform_file):
                    try:
                        with open(transform_file, "r", encoding="utf-8") as f:
                            transform_data = json.load(f)
                        transform_data["screenshots"] = sample_info["screenshots"]
                        with open(transform_file, "w", encoding="utf-8") as f:
                            json.dump(transform_data, f, indent=2)
                    except Exception as e:
                        unreal.log_warning(f"[WARNING] Failed to update transform.json: {e}")

            unreal.log(f"[OK] Screenshot: {actor_name}/{view_name} -> {os.path.basename(filename)}")

        except Exception as e:
            unreal.log_error(f"[ERROR] Failed to take screenshot for {actor_name}: {e}")

    def _execute_tick_callback(self, sample_number):
        """
        Execute tick callback code for a specific sample number.

        Args:
            sample_number: The sample number (0-indexed) to check for callbacks
        """
        if sample_number not in self.tick_callbacks:
            return

        code = self.tick_callbacks[sample_number]
        if not code:
            return

        try:
            # Create execution context with useful variables
            exec_globals = {
                "unreal": unreal,
                "sample_number": sample_number,
                "total_elapsed": self._total_elapsed,
                "actor_refs": self._actor_refs,
                "metadata": self._metadata,
            }
            exec(code, exec_globals)
            unreal.log(f"[OK] Executed tick callback for sample #{sample_number}")
        except Exception as e:
            unreal.log_error(f"[ERROR] Tick callback for sample #{sample_number} failed: {e}")

    def _on_executor_complete(self, executor):
        """
        Called by executor before stopping PIE.

        This is the on_before_complete callback that saves metadata.json
        while PIE is still running.

        Args:
            executor: The PIETickExecutor instance
        """
        if self._is_complete:
            return  # Already completed

        unreal.log(f"[INFO] Tracer completing - saving metadata...")

        # Update metadata
        self._metadata["duration"] = round(self._total_elapsed, 3)
        self._metadata["sample_count"] = self._sample_count
        self._metadata["end_time"] = datetime.now().isoformat()
        self._metadata["actors"] = list(self._actor_labels.values())
        self._metadata["actors_not_found"] = self._actors_not_found

        # Write metadata.json
        metadata_file = os.path.join(self.output_dir, "metadata.json")
        try:
            with open(metadata_file, "w", encoding="utf-8") as f:
                json.dump(self._metadata, f, indent=2)
            unreal.log(f"[OK] Wrote metadata file: {metadata_file}")
        except Exception as e:
            unreal.log_error(f"[ERROR] Failed to write metadata file: {e}")

        # Build result
        self._result = {
            "success": True,
            "output_dir": self.output_dir,
            "duration": self._total_elapsed,
            "interval": self.interval_seconds,
            "sample_count": self._sample_count,
            "actor_count": len(self._actor_refs),
            "actors_not_found": self._actors_not_found,
        }

        # Resume game if paused before stopping PIE
        if self._is_paused_for_screenshots:
            self._pause_game(False)

        # Destroy camera before PIE stops
        self._destroy_scene_capture()

        # Mark as complete (executor will stop PIE and itself)
        self._is_complete = True
        self._is_running = False
        self._executor = None

        screenshot_info = " with screenshots" if self.capture_screenshots else ""
        unreal.log(
            f"[OK] PIE tracing completed - {self._sample_count} samples in {self._total_elapsed:.1f}s{screenshot_info}"
        )
        unreal.log(f"[OK] Output directory: {self.output_dir}")

        # Write completion file for MCP server to detect
        if self.task_id:
            project_dir = unreal.Paths.project_dir()
            completion_file = os.path.join(
                project_dir, "Saved", "Logs", f"{self.task_id}_completed"
            )
            with open(completion_file, "w", encoding="utf-8") as f:
                json.dump(self._result, f)
            unreal.log(f"[OK] Wrote completion file: {completion_file}")

    @property
    def is_complete(self):
        """Check if tracing has completed (duration reached or manually stopped)."""
        return self._is_complete

    def get_result(self):
        """
        Get the trace result.

        Returns:
            dict with success, output_file, duration, interval, sample_count, actor_count, actors_not_found
            or None if not complete
        """
        return self._result


# ============================================
# MODULE-LEVEL FUNCTIONS
# ============================================

# Global instance
_tracer_instance = None


def start_pie_tracer(
    output_dir,
    actor_names,
    interval_seconds=0.1,
    auto_start_pie=False,
    duration=None,
    auto_stop_pie=True,
    task_id=None,
    tick_callbacks=None,
    # Screenshot capture options
    capture_screenshots=False,
    camera_distance=300,
    target_height=90,
    resolution=(800, 600),
    multi_angle=True,
    views=None,
):
    """
    Start PIE actor tracer.

    Args:
        output_dir: Output directory for trace data (will contain actor subdirectories)
        actor_names: List of actor names to track
        interval_seconds: Sampling interval in seconds
        auto_start_pie: Whether to auto-start PIE
        duration: Auto-stop after this many seconds
        auto_stop_pie: Whether to stop PIE when duration reached
        task_id: Unique task identifier for completion file
        tick_callbacks: Dict mapping sample numbers to Python code strings to execute.
                       Example: {0: "print('First sample')", 5: "custom_code()"}
        capture_screenshots: Whether to capture screenshots of actors (default: False)
        camera_distance: Camera distance from actor for screenshots (default: 300)
        target_height: Target height offset from actor origin (default: 90)
        resolution: Screenshot resolution as (width, height) tuple (default: (800, 600))
        multi_angle: Whether to capture multiple angles (default: True)
        views: Custom view configurations (defaults to PIE_TRACER_VIEWS)

    Returns:
        PIETracer instance
    """
    global _tracer_instance

    if _tracer_instance is not None:
        _tracer_instance.stop()

    _tracer_instance = PIETracer(
        output_dir=output_dir,
        actor_names=actor_names,
        interval_seconds=interval_seconds,
        duration=duration,
        auto_stop_pie=auto_stop_pie,
        task_id=task_id,
        tick_callbacks=tick_callbacks,
        capture_screenshots=capture_screenshots,
        camera_distance=camera_distance,
        target_height=target_height,
        resolution=resolution,
        multi_angle=multi_angle,
        views=views,
    )
    _tracer_instance.start()

    # Auto-start PIE if requested (use executor's public method)
    if auto_start_pie and _tracer_instance._executor:
        _tracer_instance._executor.request_start_pie()

    return _tracer_instance


def stop_pie_tracer():
    """Stop PIE actor tracer."""
    global _tracer_instance
    if _tracer_instance is not None:
        _tracer_instance.stop()
        _tracer_instance = None


def get_pie_tracer():
    """Get current tracer instance."""
    return _tracer_instance
