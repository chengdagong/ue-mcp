# asset_diagnostic/diagnostics/level.py
# Level/Map asset diagnostic

import gc
import unreal
import math
from typing import List, Dict, Any, Optional, Set
from dataclasses import dataclass

from .base import BaseDiagnostic
from ..core import AssetType, DiagnosticResult, IssueSeverity
from ..utils import (
    get_actor_size,
    calculate_distance,
    aabb_intersects,
    is_horizontal_orientation,
    get_actor_bounds,
)


# Actor classes that are considered "tangible" (have physical presence)
TANGIBLE_CLASSES = [
    "StaticMeshActor",
    "SkeletalMeshActor",
    "Character",
    "Pawn",
    "PlayerStart",
]

# Non-physical actor classes to skip
NON_PHYSICAL_CLASSES = [
    "DirectionalLight",
    "PointLight",
    "SpotLight",
    "RectLight",
    "SkyLight",
    "SkyAtmosphere",
    "VolumetricCloud",
    "ExponentialHeightFog",
    "AtmosphericFog",
    "Fog",
    "PostProcessVolume",
    "LightmassImportanceVolume",
    "NavMeshBoundsVolume",
    "BlockingVolume",
    "CameraActor",
    "LevelSequenceActor",
    "Note",
    "WorldSettings",
]

# Ground detection constants
GROUND_CLASSES = ["Landscape", "LandscapeProxy", "LandscapeStreamingProxy"]
GROUND_AREA_THRESHOLD = 100000  # 1000x100 units minimum area for flat surface detection
GROUND_FLATNESS_RATIO = 5  # XY extent must be 5x greater than Z extent
GROUND_TAGS = ["Ground", "Floor"]  # Tags that identify ground actors

# Orientation tolerance for character checks
HORIZONTAL_TOLERANCE_DEGREES = 5.0

# Semantic section prefixes for LLM-friendly output
# These prefixes help LLMs parse and understand diagnostic output structure
_SEC_CONTEXT = "[CONTEXT]"  # Factual data about the problematic state
_SEC_DATA = "[DATA]"  # Raw data points
_SEC_EXPECTED = "[EXPECTED]"  # What the correct state should be
_SEC_IMPACT = "[IMPACT]"  # Why this is a problem (consequence)
_SEC_THRESHOLD = "[THRESHOLD]"  # Threshold values and comparisons
_SEC_VIOLATION = "[VIOLATION]"  # Specific threshold violations
_SEC_INFO = "[INFO]"  # Additional informational context


@dataclass
class ActorSupportInfo:
    """Information about an actor for support chain analysis."""

    actor: unreal.Actor
    origin: unreal.Vector
    box_extent: unreal.Vector
    is_supported: bool = False
    support_depth: int = -1  # -1=unsupported, 0=ground, 1+=chain depth


@dataclass
class FloatingCluster:
    """A cluster of connected floating actors."""

    actors: List[unreal.Actor]
    bounds_min: unreal.Vector  # Cluster bounding box min
    bounds_max: unreal.Vector  # Cluster bounding box max


# Essential lighting actors for outdoor levels
ESSENTIAL_LIGHTING_ACTORS = [
    ("DirectionalLight", "Primary sun/moon light source"),
    ("SkyLight", "Ambient sky illumination"),
    ("SkyAtmosphere", "Atmospheric scattering and sky rendering"),
    ("ExponentialHeightFog", "Distance fog and atmospheric haze"),
]


class LevelDiagnostic(BaseDiagnostic):
    """
    Diagnostic for UE5 Level/Map assets.

    Checks for:
    - Missing PlayerStart
    - Actor positioning issues
    - Spatial layout analysis
    - Potential collision issues (with attach relationship exclusion)
    - Floating objects (support chain propagation)
    - Character orientation (pitch/roll within ±5°)
    - Duplicate blueprint instances (multiple actors of same blueprint class)
    - Missing essential lighting actors (DirectionalLight, SkyLight, etc.)
    """

    @property
    def supported_types(self) -> List[AssetType]:
        return [AssetType.LEVEL]

    # =========================================================================
    # Helper Methods for LLM-Friendly Output Formatting
    # =========================================================================

    def _format_position(self, x: float, y: float, z: float) -> str:
        """Format position as 'Position(X=100.0, Y=200.0, Z=300.0)'."""
        return f"Position(X={x:.1f}, Y={y:.1f}, Z={z:.1f})"

    def _format_bbox(self, x_ext: float, y_ext: float, z_ext: float) -> str:
        """Format bounding box extent as 'BoundingBox(50, 50, 50)'."""
        return f"BoundingBox({x_ext:.0f}, {y_ext:.0f}, {z_ext:.0f})"

    def _format_range(self, min_val: float, max_val: float) -> str:
        """Format range as 'Range[min, max]'."""
        return f"Range[{min_val:.0f}, {max_val:.0f}]"

    def _format_actor_context(self, name: str, class_name: str, x: float, y: float, z: float) -> str:
        """Format actor context line with name, class, and position."""
        return f"Actor: {name} | Class: {class_name} | {self._format_position(x, y, z)}"

    def diagnose(self, asset_path: str = None) -> DiagnosticResult:
        """
        Perform level diagnostics.

        Args:
            asset_path: Optional level path. If None, uses current open level.

        Returns:
            DiagnosticResult with issues found
        """
        # Get current level if path not specified
        if asset_path is None:
            asset_path = self._get_current_level_path() or "CurrentLevel"
        else:
            # CRITICAL: Ensure the specified level is loaded before diagnostics
            # Without this, we would analyze actors from the wrong level
            self._ensure_level_loaded(asset_path)

        result = self._create_result(asset_path, AssetType.LEVEL)

        # Get all actors
        actors = self._get_all_actors()
        if not actors:
            result.add_issue(
                IssueSeverity.ERROR,
                "Level",
                "Level contains no actors (diagnostic checks skipped)",
            )
            return result

        result.metadata["total_actors"] = len(actors)

        # Get tangible actors for spatial analysis
        tangible_actors = self._get_tangible_actors(actors)
        result.metadata["tangible_actors"] = len(tangible_actors)

        # Run diagnostic checks
        self._check_player_start(actors, result)
        self._check_actor_positions(tangible_actors, result)
        self._check_overlapping_actors(tangible_actors, result)
        self._check_floating_actors(actors, result)
        self._check_character_orientation(actors, result)
        self._check_duplicate_blueprints(actors, result)
        self._check_lighting_actors(actors, result)

        # Generate spatial analysis
        spatial_info = self._generate_spatial_analysis(tangible_actors)
        result.metadata.update(spatial_info)

        return result

    def _get_current_level_path(self) -> Optional[str]:
        """Get the path of the currently open level."""
        try:
            editor_subsystem = unreal.get_editor_subsystem(unreal.UnrealEditorSubsystem)
            world = editor_subsystem.get_editor_world()
            if world:
                level = world.get_outer()
                if level:
                    path = level.get_path_name()
                    # Release UE object references to avoid memory leaks
                    del level
                    del world
                    return path
            # Release reference if world was valid but level wasn't
            if world:
                del world
        except Exception:
            pass
        return None

    def _ensure_level_loaded(self, target_level: str) -> None:
        """
        Ensure the specified level is loaded before diagnostics.

        This is critical for correctly diagnosing actors in a specific level.
        Without this, diagnostics would analyze actors from whatever level
        is currently open, not the requested level.

        Args:
            target_level: Level path to load (e.g., "/Game/Maps/MyLevel")

        Raises:
            RuntimeError: If level cannot be loaded or has unsaved changes
        """
        level_subsystem = unreal.get_editor_subsystem(unreal.LevelEditorSubsystem)
        if not level_subsystem:
            raise RuntimeError("Could not get LevelEditorSubsystem")

        # Get current level info - extract all needed data immediately
        # and release UE object references to avoid blocking GC
        current_level_obj = level_subsystem.get_current_level()
        if not current_level_obj:
            raise RuntimeError("Could not get current level")

        current_package = current_level_obj.get_outermost()
        current_level_full = current_package.get_name()  # e.g., "/Temp/Untitled_1"
        current_level_path = current_package.get_path_name()
        current_level_name = (
            current_level_full.split("/")[-1] if "/" in current_level_full else current_level_full
        )

        # CRITICAL: Release UE object references immediately after extracting string data
        # This allows UE's GC to clean up the old level when we load a new one
        del current_package
        del current_level_obj

        # Extract target name for comparison
        target_name = target_level.split("/")[-1] if "/" in target_level else target_level

        # Check if target matches current level (by name or path)
        # Use strict matching to avoid false positives
        is_same_level = (
            current_level_name == target_name
            or current_level_full == target_level
            or current_level_path == target_level
            or current_level_path.endswith(f"/{target_name}")
            or
            # Handle Untitled -> Untitled_N matching (new empty levels)
            (target_name.lower() == "untitled" and current_level_name.lower().startswith("untitled"))
        )

        if is_same_level:
            # Already on the correct level
            return

        # Need to load a different level
        # Check if current level has unsaved changes
        try:
            dirty_content = unreal.EditorLoadingAndSavingUtils.get_dirty_content_packages()
            dirty_maps = unreal.EditorLoadingAndSavingUtils.get_dirty_map_packages()
            if dirty_content or dirty_maps:
                raise RuntimeError(
                    f"Current level '{current_level_name}' has unsaved changes. "
                    f"Please save or discard them before loading '{target_level}'."
                )
        except AttributeError:
            # EditorLoadingAndSavingUtils may not have these methods in all UE versions
            pass

        # Force Python garbage collection before loading new level
        # This ensures any remaining UE object references are released
        gc.collect()

        if not level_subsystem.load_level(target_level):
            raise RuntimeError(f"Failed to load level: {target_level}")

        # Wait briefly for level to fully load
        # This is important because actors may not be immediately available
        import time
        time.sleep(0.5)

    def _get_all_actors(self) -> List[unreal.Actor]:
        """Get all actors in the current level."""
        try:
            actor_subsystem = unreal.get_editor_subsystem(unreal.EditorActorSubsystem)
            return list(actor_subsystem.get_all_level_actors())
        except Exception:
            return []

    def _is_tangible_actor(self, actor) -> bool:
        """Check if an actor has physical presence."""
        class_name = actor.get_class().get_name()

        for skip in NON_PHYSICAL_CLASSES:
            if skip.lower() in class_name.lower():
                return False

        for tangible in TANGIBLE_CLASSES:
            if tangible.lower() in class_name.lower():
                return True

        # Blueprint classes end with _C
        if class_name.endswith("_C"):
            return True

        return False

    def _get_tangible_actors(self, actors: List[unreal.Actor]) -> List[Dict[str, Any]]:
        """Get tangible actors with their position/size data."""
        tangible = []
        for actor in actors:
            if not self._is_tangible_actor(actor):
                continue

            size = get_actor_size(actor)
            if not size:
                continue

            location = actor.get_actor_location()
            tangible.append(
                {
                    "name": actor.get_actor_label(),
                    "class": actor.get_class().get_name(),
                    "x": location.x,
                    "y": location.y,
                    "z": location.z,
                    "x_extent": size[0],
                    "y_extent": size[1],
                    "z_extent": size[2],
                    "actor": actor,
                }
            )
        return tangible

    def _check_player_start(self, actors: List[unreal.Actor], result: DiagnosticResult):
        """Check for PlayerStart presence and configuration."""
        player_starts = [a for a in actors if isinstance(a, unreal.PlayerStart)]

        if not player_starts:
            result.add_issue(
                IssueSeverity.ERROR,
                "Gameplay",
                "Missing PlayerStart actor (players cannot spawn)",
                details=[
                    f"{_SEC_CONTEXT} Searched all actors in level: 0 PlayerStart instances found",
                    f"{_SEC_EXPECTED} At least 1 PlayerStart actor required for player spawning",
                    f"{_SEC_IMPACT} Players cannot spawn into this level; game will fail to start or use fallback spawn location",
                ],
                suggestion="Add PlayerStart actor: Place at desired spawn location with Z-position above ground level",
            )
        elif len(player_starts) > 1:
            ps_names = [ps.get_actor_label() for ps in player_starts]
            result.add_issue(
                IssueSeverity.INFO,
                "Gameplay",
                f"Multiple PlayerStart actors found ({len(player_starts)} instances, spawn may vary)",
                details=[
                    f"{_SEC_CONTEXT} PlayerStart instances found: {', '.join(ps_names)}",
                    f"{_SEC_EXPECTED} Single PlayerStart for deterministic spawning, or multiple for multiplayer/random spawn",
                    f"{_SEC_INFO} UE5 selects spawn location based on game mode logic; multiple may cause unpredictable spawn points",
                ],
            )
        # Check each PlayerStart for position and orientation issues
        for ps in player_starts:
            location = ps.get_actor_location()
            ps_name = ps.get_actor_label()

            # Check for very low Z position
            if location.z < -1000:
                result.add_issue(
                    IssueSeverity.ERROR,
                    "Gameplay",
                    "PlayerStart below minimum Z threshold (player may spawn in void)",
                    actor=ps_name,
                    details=[
                        f"{_SEC_CONTEXT} {self._format_actor_context(ps_name, 'PlayerStart', location.x, location.y, location.z)}",
                        f"{_SEC_THRESHOLD} Minimum valid Z: -1000 units | Current Z: {location.z:.0f} units | Violation: {abs(location.z + 1000):.0f} units below threshold",
                        f"{_SEC_EXPECTED} PlayerStart Z-position should be >= -1000 units (above typical kill-Z plane)",
                        f"{_SEC_IMPACT} Player may spawn inside geometry, fall through world, or trigger kill volume",
                    ],
                    suggestion=f"Move PlayerStart to Z >= -1000: Set new position to approximately {self._format_position(location.x, location.y, 0)} or above nearest walkable surface",
                )

            # Check for non-horizontal facing direction
            is_horizontal, pitch, roll = is_horizontal_orientation(ps, HORIZONTAL_TOLERANCE_DEGREES)
            if not is_horizontal:
                rotation = ps.get_actor_rotation()
                details = [
                    f"{_SEC_CONTEXT} {self._format_actor_context(ps_name, 'PlayerStart', location.x, location.y, location.z)}",
                    f"{_SEC_DATA} Current rotation: Pitch={pitch:.1f}, Roll={roll:.1f}, Yaw={rotation.yaw:.1f}",
                    f"{_SEC_THRESHOLD} Horizontal tolerance: Pitch and Roll within +/-{HORIZONTAL_TOLERANCE_DEGREES:.1f} degrees of zero",
                ]
                violations = []
                if abs(pitch) > HORIZONTAL_TOLERANCE_DEGREES:
                    violations.append(
                        f"Pitch={pitch:.1f} exceeds tolerance by {abs(pitch) - HORIZONTAL_TOLERANCE_DEGREES:.1f} degrees"
                    )
                if abs(roll) > HORIZONTAL_TOLERANCE_DEGREES:
                    violations.append(
                        f"Roll={roll:.1f} exceeds tolerance by {abs(roll) - HORIZONTAL_TOLERANCE_DEGREES:.1f} degrees"
                    )
                if violations:
                    details.append(f"{_SEC_VIOLATION} {' | '.join(violations)}")
                details.extend([
                    f"{_SEC_EXPECTED} Pitch=0.0 (+/-{HORIZONTAL_TOLERANCE_DEGREES:.1f}), Roll=0.0 (+/-{HORIZONTAL_TOLERANCE_DEGREES:.1f}), Yaw=any (determines spawn facing direction)",
                    f"{_SEC_IMPACT} Spawned player character will be tilted; may cause disorientation and control issues",
                ])
                result.add_issue(
                    IssueSeverity.WARNING,
                    "Orientation",
                    "PlayerStart has non-horizontal orientation (player will spawn tilted)",
                    actor=ps_name,
                    details=details,
                    suggestion=f"Reset PlayerStart rotation: Set Pitch=0, Roll=0, keep Yaw={rotation.yaw:.1f} for spawn direction",
                )

        result.metadata["player_start_count"] = len(player_starts)

    def _check_actor_positions(self, actors: List[Dict[str, Any]], result: DiagnosticResult):
        """Check for suspicious actor positions."""
        for actor in actors:
            # Check for actors at world origin (might be unintentional)
            if abs(actor["x"]) < 1 and abs(actor["y"]) < 1 and abs(actor["z"]) < 1:
                result.add_issue(
                    IssueSeverity.INFO,
                    "Position",
                    "Actor positioned at world origin (possibly unplaced)",
                    actor=actor["name"],
                    details=[
                        f"{_SEC_CONTEXT} {self._format_actor_context(actor['name'], actor['class'], actor['x'], actor['y'], actor['z'])}",
                        f"{_SEC_THRESHOLD} Origin detection radius: 1.0 unit from {self._format_position(0, 0, 0)}",
                        f"{_SEC_EXPECTED} Intentionally placed actors typically have non-origin positions matching level design",
                        f"{_SEC_INFO} Common causes: Newly spawned actor not yet positioned, reset transform, or intentional origin placement",
                    ],
                )

            # Check for actors at extreme positions
            if abs(actor["x"]) > 1000000 or abs(actor["y"]) > 1000000 or abs(actor["z"]) > 1000000:
                # Determine which axes exceed threshold
                violations = []
                if abs(actor["x"]) > 1000000:
                    violations.append(f"X={actor['x']:.0f} exceeds by {abs(actor['x']) - 1000000:.0f}")
                if abs(actor["y"]) > 1000000:
                    violations.append(f"Y={actor['y']:.0f} exceeds by {abs(actor['y']) - 1000000:.0f}")
                if abs(actor["z"]) > 1000000:
                    violations.append(f"Z={actor['z']:.0f} exceeds by {abs(actor['z']) - 1000000:.0f}")

                result.add_issue(
                    IssueSeverity.ERROR,
                    "Position",
                    "Actor positioned outside playable bounds (extreme coordinate detected)",
                    actor=actor["name"],
                    details=[
                        f"{_SEC_CONTEXT} {self._format_actor_context(actor['name'], actor['class'], actor['x'], actor['y'], actor['z'])}",
                        f"{_SEC_THRESHOLD} Maximum valid position: +/-1,000,000 units per axis",
                        f"{_SEC_VIOLATION} {' | '.join(violations)}",
                        f"{_SEC_EXPECTED} Actors should be within playable world bounds: X, Y, Z each in {self._format_range(-1000000, 1000000)}",
                        f"{_SEC_IMPACT} Actor is outside playable area; may cause rendering issues, physics errors, or be unreachable",
                    ],
                    suggestion=f"Relocate actor to valid bounds: Move to position within {self._format_range(-1000000, 1000000)} on all axes",
                )

    def _check_overlapping_actors(self, actors: List[Dict[str, Any]], result: DiagnosticResult):
        """
        Check for potentially overlapping actors using AABB intersection.

        Detects two types of overlaps:
        1. AABB intersection: Bounding boxes of two actors intersect
        2. Containment: One actor's origin is inside another actor's bounding box

        Excludes actors with parent-child attachment relationships from
        being flagged as overlapping.
        """
        overlap_count = 0
        containment_count = 0

        for i, a1 in enumerate(actors):
            a1_actor = a1["actor"]
            a1_exclude = self._build_attach_exclude_set(a1_actor)

            # Get a1's bounds (origin is actor position, extent is half-size)
            a1_origin = (a1["x"], a1["y"], a1["z"])
            a1_extent = (a1["x_extent"] / 2, a1["y_extent"] / 2, a1["z_extent"] / 2)

            for a2 in actors[i + 1 :]:
                a2_actor = a2["actor"]

                # Skip if actors have attachment relationship
                if a2_actor in a1_exclude:
                    continue

                # Get a2's bounds
                a2_origin = (a2["x"], a2["y"], a2["z"])
                a2_extent = (a2["x_extent"] / 2, a2["y_extent"] / 2, a2["z_extent"] / 2)

                # Check AABB intersection
                if not aabb_intersects(a1_origin, a1_extent, a2_origin, a2_extent):
                    continue

                # AABBs intersect - determine the type of overlap
                dist = calculate_distance(a1, a2)

                # Check for containment: is one actor's origin inside the other's bounds?
                a1_inside_a2 = self._point_inside_aabb(a1_origin, a2_origin, a2_extent)
                a2_inside_a1 = self._point_inside_aabb(a2_origin, a1_origin, a1_extent)

                # Calculate overlap volume for severity assessment
                overlap_volume = self._calculate_overlap_volume(
                    a1_origin, a1_extent, a2_origin, a2_extent
                )
                a1_volume = a1["x_extent"] * a1["y_extent"] * a1["z_extent"]
                a2_volume = a2["x_extent"] * a2["y_extent"] * a2["z_extent"]
                smaller_volume = min(a1_volume, a2_volume)
                overlap_ratio = overlap_volume / smaller_volume if smaller_volume > 0 else 0

                # Determine severity based on overlap characteristics
                if a1_inside_a2 or a2_inside_a1:
                    # Containment case: one actor's origin is inside another
                    containment_count += 1
                    contained = a1 if a1_inside_a2 else a2
                    container = a2 if a1_inside_a2 else a1

                    # Report containment cases as INFO (may be intentional layering)
                    if overlap_ratio > 0.85:
                        severity = IssueSeverity.INFO
                        message = "Actor fully contained inside another actor"
                    elif overlap_ratio > 0.3:
                        severity = IssueSeverity.WARNING
                        message = "Actor origin inside another actor's bounds (significant overlap)"
                    else:
                        severity = IssueSeverity.INFO
                        message = "Actor origin inside another actor's bounds (partial overlap)"

                    result.add_issue(
                        severity,
                        "Collision",
                        message,
                        details=[
                            f"{_SEC_CONTEXT} Containment detected: one actor's origin point is inside another actor's bounding box",
                            f"{_SEC_DATA} Container: {container['name']} | Class: {container['class']}",
                            f"  {self._format_position(container['x'], container['y'], container['z'])} | {self._format_bbox(container['x_extent'], container['y_extent'], container['z_extent'])}",
                            f"{_SEC_DATA} Contained: {contained['name']} | Class: {contained['class']}",
                            f"  {self._format_position(contained['x'], contained['y'], contained['z'])} | {self._format_bbox(contained['x_extent'], contained['y_extent'], contained['z_extent'])}",
                            f"{_SEC_DATA} Center distance: {dist:.1f} units | Overlap ratio: {overlap_ratio:.1%} of smaller actor",
                            f"{_SEC_EXPECTED} Actors should have non-overlapping bounding boxes unless intentionally layered",
                            f"{_SEC_IMPACT} Overlapping actors may cause physics glitches, z-fighting, or unintended collisions",
                        ],
                        suggestion=f"Separate actors: Move '{contained['name']}' outside '{container['name']}' bounds, or verify this overlap is intentional",
                    )
                else:
                    # Intersection case: bounding boxes overlap but neither origin is inside the other
                    overlap_count += 1

                    # Same-class overlap at nearly identical position is likely duplicate
                    if dist < 10 and a1["class"] == a2["class"]:
                        result.add_issue(
                            IssueSeverity.WARNING,
                            "Collision",
                            "Same-class actors at near-identical position (possible duplicate)",
                            details=[
                                f"{_SEC_CONTEXT} Actor pair detected with near-identical positions",
                                f"{_SEC_DATA} Actor1: {a1['name']} | {self._format_position(a1['x'], a1['y'], a1['z'])} | {self._format_bbox(a1['x_extent'], a1['y_extent'], a1['z_extent'])}",
                                f"{_SEC_DATA} Actor2: {a2['name']} | {self._format_position(a2['x'], a2['y'], a2['z'])} | {self._format_bbox(a2['x_extent'], a2['y_extent'], a2['z_extent'])}",
                                f"{_SEC_DATA} Class: {a1['class']} | Center distance: {dist:.1f} units",
                                f"{_SEC_THRESHOLD} Duplicate detection: same class + distance < 10 units",
                                f"{_SEC_INFO} May indicate accidental duplicate placement or copy-paste error",
                            ],
                            suggestion="Remove duplicate: Delete one of the actors if unintentional duplication",
                        )
                    elif overlap_ratio > 0.5:
                        # Significant overlap between different actors
                        result.add_issue(
                            IssueSeverity.WARNING,
                            "Collision",
                            "Actors have significant bounding box overlap",
                            details=[
                                f"{_SEC_CONTEXT} AABB intersection detected between two actors",
                                f"{_SEC_DATA} Actor1: {a1['name']} | Class: {a1['class']}",
                                f"  {self._format_position(a1['x'], a1['y'], a1['z'])} | {self._format_bbox(a1['x_extent'], a1['y_extent'], a1['z_extent'])}",
                                f"{_SEC_DATA} Actor2: {a2['name']} | Class: {a2['class']}",
                                f"  {self._format_position(a2['x'], a2['y'], a2['z'])} | {self._format_bbox(a2['x_extent'], a2['y_extent'], a2['z_extent'])}",
                                f"{_SEC_DATA} Center distance: {dist:.1f} units | Overlap ratio: {overlap_ratio:.1%} of smaller actor",
                                f"{_SEC_EXPECTED} Non-attached actors typically have minimal bounding box overlap",
                                f"{_SEC_IMPACT} May cause physics collision issues or visual z-fighting",
                            ],
                            suggestion="Adjust positions to reduce overlap, or verify this intersection is intentional",
                        )
                    else:
                        # Minor overlap - just informational
                        result.add_issue(
                            IssueSeverity.INFO,
                            "Collision",
                            "Actors have minor bounding box overlap",
                            details=[
                                f"{_SEC_CONTEXT} AABB edges intersecting between two actors",
                                f"{_SEC_DATA} Actor1: {a1['name']} | {self._format_position(a1['x'], a1['y'], a1['z'])}",
                                f"{_SEC_DATA} Actor2: {a2['name']} | {self._format_position(a2['x'], a2['y'], a2['z'])}",
                                f"{_SEC_DATA} Center distance: {dist:.1f} units | Overlap ratio: {overlap_ratio:.1%}",
                                f"{_SEC_INFO} Minor overlaps are often acceptable for adjacent objects",
                            ],
                        )

        # Store overlap statistics in metadata
        result.metadata["overlapping_actor_pairs"] = overlap_count
        result.metadata["containment_cases"] = containment_count

    def _point_inside_aabb(
        self, point: tuple, box_origin: tuple, box_extent: tuple, epsilon: float = 0.1
    ) -> bool:
        """
        Check if a point is inside an axis-aligned bounding box.

        Args:
            point: (x, y, z) coordinates of the point
            box_origin: (x, y, z) center of the AABB
            box_extent: (x, y, z) half-extents of the AABB
            epsilon: Tolerance for boundary checks

        Returns:
            True if point is inside or on the boundary of the AABB
        """
        for i in range(3):
            if point[i] < box_origin[i] - box_extent[i] - epsilon:
                return False
            if point[i] > box_origin[i] + box_extent[i] + epsilon:
                return False
        return True

    def _calculate_overlap_volume(
        self,
        origin1: tuple,
        extent1: tuple,
        origin2: tuple,
        extent2: tuple,
    ) -> float:
        """
        Calculate the volume of intersection between two AABBs.

        Args:
            origin1, extent1: First AABB center and half-extents
            origin2, extent2: Second AABB center and half-extents

        Returns:
            Volume of the intersection region (0 if no intersection)
        """
        overlap_dims = []
        for i in range(3):
            min1 = origin1[i] - extent1[i]
            max1 = origin1[i] + extent1[i]
            min2 = origin2[i] - extent2[i]
            max2 = origin2[i] + extent2[i]

            overlap_min = max(min1, min2)
            overlap_max = min(max1, max2)
            overlap_size = max(0, overlap_max - overlap_min)
            overlap_dims.append(overlap_size)

        return overlap_dims[0] * overlap_dims[1] * overlap_dims[2]

    def _generate_spatial_analysis(self, actors: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate spatial analysis metadata."""
        if not actors:
            return {}

        min_x = min(a["x"] for a in actors)
        max_x = max(a["x"] for a in actors)
        min_y = min(a["y"] for a in actors)
        max_y = max(a["y"] for a in actors)
        min_z = min(a["z"] for a in actors)
        max_z = max(a["z"] for a in actors)

        return {
            "level_bounds": {
                "min": (min_x, min_y, min_z),
                "max": (max_x, max_y, max_z),
            },
            "level_dimensions": {
                "width": max_x - min_x,
                "length": max_y - min_y,
                "height": max_z - min_z,
            },
            "level_center": (
                (min_x + max_x) / 2,
                (min_y + max_y) / 2,
                (min_z + max_z) / 2,
            ),
        }

    # =========================================================================
    # Ground and Floating Object Detection
    # =========================================================================

    def _is_ground_actor(self, actor: unreal.Actor) -> bool:
        """
        Check if an actor qualifies as a ground surface.

        Criteria:
        1. Landscape class actors
        2. Large flat StaticMesh surfaces
        3. Actors with "Ground" or "Floor" tags
        """
        class_name = actor.get_class().get_name()

        # Check if it's a Landscape class
        for ground_class in GROUND_CLASSES:
            if ground_class.lower() in class_name.lower():
                return True

        # Check for Ground/Floor tags
        try:
            tags = actor.tags
            if tags:
                for tag in tags:
                    tag_str = str(tag)
                    for ground_tag in GROUND_TAGS:
                        if ground_tag.lower() in tag_str.lower():
                            return True
        except Exception:
            pass

        # Check for large flat surfaces (StaticMeshActor)
        if "staticmesh" in class_name.lower():
            origin, extent = get_actor_bounds(actor)
            if origin and extent:
                xy_area = extent.x * extent.y * 4  # Full area (extent is half-size)
                avg_xy = (extent.x + extent.y) / 2
                z_extent = extent.z

                # Must be large enough and flat
                if (
                    xy_area > GROUND_AREA_THRESHOLD
                    and z_extent > 0
                    and avg_xy > z_extent * GROUND_FLATNESS_RATIO
                ):
                    return True

        return False

    def _identify_ground_actors(self, actors: List[unreal.Actor]) -> List[unreal.Actor]:
        """
        Identify all actors that serve as ground/floor surfaces.

        Args:
            actors: List of all actors in the level

        Returns:
            List of actors classified as ground
        """
        ground_actors = []
        for actor in actors:
            if self._is_ground_actor(actor):
                ground_actors.append(actor)
        return ground_actors

    def _build_attach_exclude_set(self, actor: unreal.Actor) -> Set[unreal.Actor]:
        """
        Build a set of actors to exclude from overlap detection due to
        parent-child attachment relationships.

        Args:
            actor: The actor to build exclusion set for

        Returns:
            Set of actors to exclude (includes self, parent, and children)
        """
        exclude = {actor}
        try:
            parent = actor.get_attach_parent_actor()
            if parent:
                exclude.add(parent)

            attached = actor.get_attached_actors()
            if attached:
                exclude.update(attached)
        except Exception:
            pass
        return exclude

    def _get_overlapping_actors_for_support(
        self,
        actor_info: ActorSupportInfo,
        all_actor_info: Dict[unreal.Actor, ActorSupportInfo],
    ) -> List[unreal.Actor]:
        """
        Find actors that overlap with the given actor (for support chain detection).
        Excludes actors with attachment relationships.

        Args:
            actor_info: The actor's support info
            all_actor_info: Dict mapping actors to their support info

        Returns:
            List of overlapping actors
        """
        overlapping = []
        exclude_set = self._build_attach_exclude_set(actor_info.actor)

        for other_actor, other_info in all_actor_info.items():
            if other_actor in exclude_set:
                continue

            # Use AABB intersection test
            if aabb_intersects(
                actor_info.origin,
                actor_info.box_extent,
                other_info.origin,
                other_info.box_extent,
            ):
                overlapping.append(other_actor)

        return overlapping

    def _detect_floating_objects(
        self, actors: List[unreal.Actor], ground_actors: List[unreal.Actor]
    ) -> tuple[List[FloatingCluster], int, Dict[unreal.Actor, ActorSupportInfo]]:
        """
        Detect floating objects using support chain propagation.

        Algorithm:
        1. Mark ground actors as supported (depth=0)
        2. Find actors overlapping ground → mark as supported (depth=1)
        3. Iteratively propagate until no new actors get support status
        4. Cluster unsupported actors into connected groups
        5. Return clusters of floating actors

        Args:
            actors: All tangible actors to check
            ground_actors: Actors identified as ground surfaces

        Returns:
            tuple: (list of FloatingCluster, max support depth, actor_info_map)
        """
        # Build actor info map (cache bounds)
        actor_info_map: Dict[unreal.Actor, ActorSupportInfo] = {}

        for actor in actors:
            origin, extent = get_actor_bounds(actor)
            if origin and extent:
                actor_info_map[actor] = ActorSupportInfo(
                    actor=actor,
                    origin=origin,
                    box_extent=extent,
                )

        # Initialize ground actors as supported (depth=0)
        ground_set = set(ground_actors)
        for actor in ground_actors:
            if actor in actor_info_map:
                actor_info_map[actor].is_supported = True
                actor_info_map[actor].support_depth = 0

        # Propagation loop
        max_depth = 0
        current_depth = 0
        changed = True

        while changed:
            changed = False
            current_depth += 1
            newly_supported = []

            # Find unsupported actors that overlap with supported actors
            for actor, info in actor_info_map.items():
                if info.is_supported:
                    continue

                # Check if this actor overlaps with any supported actor
                overlapping = self._get_overlapping_actors_for_support(info, actor_info_map)
                for other in overlapping:
                    other_info = actor_info_map.get(other)
                    if other_info and other_info.is_supported:
                        newly_supported.append((actor, current_depth))
                        break

            # Mark newly supported actors
            for actor, depth in newly_supported:
                actor_info_map[actor].is_supported = True
                actor_info_map[actor].support_depth = depth
                max_depth = max(max_depth, depth)
                changed = True

            # Prevent infinite loops (max depth 100)
            if current_depth > 100:
                break

        # Collect floating (unsupported) actors and cluster them
        floating_actors = [info.actor for info in actor_info_map.values() if not info.is_supported]
        clusters = self._cluster_floating_actors(floating_actors, actor_info_map)

        return clusters, max_depth, actor_info_map

    def _cluster_floating_actors(
        self,
        floating_actors: List[unreal.Actor],
        actor_info_map: Dict[unreal.Actor, ActorSupportInfo],
    ) -> List[FloatingCluster]:
        """
        Group floating actors into connected clusters using AABB intersection.

        Uses BFS to find connected components. Two floating actors belong to the
        same cluster if their bounding boxes intersect.

        Args:
            floating_actors: List of actors identified as floating
            actor_info_map: Dict mapping actors to their support info (contains bounds)

        Returns:
            List of FloatingCluster, each containing connected floating actors
        """
        if not floating_actors:
            return []

        floating_set = set(floating_actors)
        visited = set()
        clusters = []

        for start_actor in floating_actors:
            if start_actor in visited:
                continue

            # BFS to find all connected floating actors
            cluster_actors = []
            queue = [start_actor]

            while queue:
                current = queue.pop(0)
                if current in visited:
                    continue

                visited.add(current)
                cluster_actors.append(current)

                # Find overlapping floating actors
                if current not in actor_info_map:
                    continue

                current_info = actor_info_map[current]
                for other in floating_actors:
                    if other in visited or other not in actor_info_map:
                        continue

                    other_info = actor_info_map[other]
                    if aabb_intersects(
                        current_info.origin,
                        current_info.box_extent,
                        other_info.origin,
                        other_info.box_extent,
                    ):
                        queue.append(other)

            # Calculate cluster bounding box
            if cluster_actors:
                min_x = min_y = min_z = float("inf")
                max_x = max_y = max_z = float("-inf")

                for actor in cluster_actors:
                    if actor in actor_info_map:
                        info = actor_info_map[actor]
                        min_x = min(min_x, info.origin.x - info.box_extent.x)
                        max_x = max(max_x, info.origin.x + info.box_extent.x)
                        min_y = min(min_y, info.origin.y - info.box_extent.y)
                        max_y = max(max_y, info.origin.y + info.box_extent.y)
                        min_z = min(min_z, info.origin.z - info.box_extent.z)
                        max_z = max(max_z, info.origin.z + info.box_extent.z)

                clusters.append(
                    FloatingCluster(
                        actors=cluster_actors,
                        bounds_min=unreal.Vector(min_x, min_y, min_z),
                        bounds_max=unreal.Vector(max_x, max_y, max_z),
                    )
                )

        return clusters

    def _check_floating_actors(self, actors: List[unreal.Actor], result: DiagnosticResult):
        """
        Check for floating objects in the level.

        Args:
            actors: All actors in the level
            result: DiagnosticResult to add issues to
        """
        # Get tangible actors (raw actor list)
        tangible_actors = [a for a in actors if self._is_tangible_actor(a)]
        if not tangible_actors:
            return

        # Pre-check: Verify all Character actors have valid SkeletalMeshComponent bounds
        for actor in tangible_actors:
            if isinstance(actor, unreal.Character):
                location = actor.get_actor_location()
                actor_name = actor.get_actor_label()
                class_name = actor.get_class().get_name()

                # Check 1: Does the Character have a SkeletalMeshComponent?
                skeletal_mesh = actor.get_component_by_class(unreal.SkeletalMeshComponent)
                if not skeletal_mesh:
                    result.add_issue(
                        IssueSeverity.ERROR,
                        "Configuration",
                        "Character actor has no SkeletalMeshComponent (bounds undefined)",
                        actor=actor_name,
                        details=[
                            f"{_SEC_CONTEXT} {self._format_actor_context(actor_name, class_name, location.x, location.y, location.z)}",
                            f"{_SEC_EXPECTED} Character actors require SkeletalMeshComponent for visual mesh and collision bounds",
                            f"{_SEC_IMPACT} Cannot calculate actor bounding box; excluded from floating object detection and collision analysis",
                            f"{_SEC_INFO} Character will render as invisible (no mesh) and have no collision volume from skeletal mesh",
                        ],
                        suggestion=f"Fix Character blueprint {class_name}: Add SkeletalMeshComponent as child of CapsuleComponent, assign SkeletalMesh asset",
                    )
                    continue

                # Check 2: Can we retrieve bounds from the SkeletalMeshComponent?
                origin, extent = get_actor_bounds(actor)
                if origin is None or extent is None:
                    result.add_issue(
                        IssueSeverity.ERROR,
                        "Configuration",
                        "Character SkeletalMeshComponent returns invalid bounds (mesh configuration error)",
                        actor=actor_name,
                        details=[
                            f"{_SEC_CONTEXT} {self._format_actor_context(actor_name, class_name, location.x, location.y, location.z)}",
                            f"{_SEC_DATA} SkeletalMeshComponent: {skeletal_mesh.get_name()} | Bounds: null/zero",
                            f"{_SEC_EXPECTED} SkeletalMeshComponent.get_actor_bounds() should return non-zero extent vector",
                            f"{_SEC_IMPACT} Bounding box undefined; actor excluded from floating detection, collision checks may fail",
                            f"{_SEC_INFO} Probable cause: SkeletalMesh asset not assigned, invalid mesh reference, or mesh has no geometry",
                        ],
                        suggestion=f"Fix SkeletalMeshComponent in {class_name}: 1) Verify SkeletalMesh asset is assigned, 2) Check mesh has valid geometry, 3) Reimport mesh if bounds still zero",
                    )

        # Identify ground actors
        ground_actors = self._identify_ground_actors(actors)

        if not ground_actors:
            # No ground detected - can't determine floating status
            result.add_issue(
                IssueSeverity.INFO,
                "Physics",
                "Level has no detectable ground surface (floating object detection skipped)",
                details=[
                    f"{_SEC_CONTEXT} Ground detection searched for surfaces that support other actors",
                    f"{_SEC_DATA} Ground detection criteria (any of):",
                    f"  - Landscape/LandscapeProxy class actors: 0 found",
                    f"  - Large flat StaticMesh (area > {GROUND_AREA_THRESHOLD} sq units, XY extent > {GROUND_FLATNESS_RATIO}x Z extent): 0 found",
                    f"  - Actors tagged with {GROUND_TAGS}: 0 found",
                    f"{_SEC_EXPECTED} At least one ground surface to establish support chain for physics validation",
                    f"{_SEC_IMPACT} Cannot determine if actors are floating; support chain analysis skipped",
                ],
                suggestion="Add ground surface: Option 1) Add Landscape actor, Option 2) Place large flat mesh (e.g., 1000x1000x10 plane), Option 3) Tag existing floor actors with 'Ground' tag",
            )
            return

        # Detect floating objects (returns clusters)
        floating_clusters, max_depth, actor_info_map = self._detect_floating_objects(
            tangible_actors, ground_actors
        )

        # Build set of all floating actors for later lookups
        floating_set = set()
        for cluster in floating_clusters:
            floating_set.update(cluster.actors)

        # Store metadata
        result.metadata["ground_actors_count"] = len(ground_actors)
        result.metadata["support_chain_max_depth"] = max_depth
        result.metadata["floating_clusters_count"] = len(floating_clusters)
        result.metadata["floating_actors_count"] = len(floating_set)

        # Report each floating cluster
        for cluster in floating_clusters:
            group = cluster.actors
            actor_names = [a.get_actor_label() for a in group]

            # Build details with all actors in the cluster
            details = [
                f"{_SEC_CONTEXT} Floating detection uses support chain analysis:",
                "  - Ground actors (Landscape, large flat mesh, 'Ground'/'Floor' tagged) establish support depth 0",
                "  - Actors with bounding boxes touching supported actors inherit support (depth +1)",
                "  - Actors not in support chain are classified as 'floating'",
            ]

            # List all actors in the cluster
            details.append(f"{_SEC_DATA} Floating actors in cluster ({len(group)}):")
            for actor in group:
                a_name = actor.get_actor_label()
                a_class = actor.get_class().get_name()
                a_location = actor.get_actor_location()
                a_origin, a_extent = get_actor_bounds(actor)

                bbox_str = self._format_bbox(a_extent.x, a_extent.y, a_extent.z) if a_extent else "BoundingBox(unknown)"
                details.append(
                    f"  - {a_name} | Class: {a_class} | {self._format_position(a_location.x, a_location.y, a_location.z)} | {bbox_str}"
                )

            # Cluster bounding box info
            group_min_z = cluster.bounds_min.z

            details.append(
                f"{_SEC_DATA} Cluster bounds: "
                f"X: {self._format_range(cluster.bounds_min.x, cluster.bounds_max.x)} | "
                f"Y: {self._format_range(cluster.bounds_min.y, cluster.bounds_max.y)} | "
                f"Z: {self._format_range(cluster.bounds_min.z, cluster.bounds_max.z)}"
            )

            # Calculate cluster center for distance calculations
            cluster_center_x = (cluster.bounds_min.x + cluster.bounds_max.x) / 2
            cluster_center_y = (cluster.bounds_min.y + cluster.bounds_max.y) / 2
            cluster_center_z = (cluster.bounds_min.z + cluster.bounds_max.z) / 2

            # Find nearest ground and calculate gap
            nearest_ground = None
            nearest_ground_dist = float("inf")
            gap = 0.0
            for g in ground_actors:
                g_loc = g.get_actor_location()
                dist = math.sqrt(
                    (cluster_center_x - g_loc.x) ** 2
                    + (cluster_center_y - g_loc.y) ** 2
                    + (cluster_center_z - g_loc.z) ** 2
                )
                if dist < nearest_ground_dist:
                    nearest_ground_dist = dist
                    nearest_ground = g

            if nearest_ground:
                g_origin, g_extent = get_actor_bounds(nearest_ground)
                if g_origin and g_extent:
                    ground_top_z = g_origin.z + g_extent.z
                    gap = group_min_z - ground_top_z
                    details.append(
                        f"{_SEC_DATA} Gap analysis: Nearest ground '{nearest_ground.get_actor_label()}' | "
                        f"Ground top Z: {ground_top_z:.0f} | Cluster bottom Z: {group_min_z:.0f} | Vertical gap: {gap:.0f} units"
                    )

            details.extend([
                f"{_SEC_EXPECTED} All physical actors should be in support chain (touching ground or ground-connected actor)",
                f"{_SEC_IMPACT} Actors will fall when physics simulates; may indicate incomplete level construction or missing support geometry",
            ])

            # Create issue message and actor field based on group size
            if len(group) > 1:
                issue_message = f"Floating actor group detected ({len(group)} actors will fall when physics simulates)"
                actor_field = ", ".join(actor_names)
                suggestion = f"Ground the cluster: Option 1) Lower Z-position by ~{gap:.0f} units to contact ground, Option 2) Add supporting actor (pillar/platform) below, Option 3) If intentionally floating, disable physics simulation"
            else:
                issue_message = "Floating actor detected (will fall when physics simulates)"
                actor_field = actor_names[0]
                suggestion = f"Ground the actor: Option 1) Lower Z-position by ~{gap:.0f} units to contact ground, Option 2) Add supporting geometry below, Option 3) If intentionally floating, disable physics simulation"

            result.add_issue(
                IssueSeverity.ERROR,
                "Physics",
                issue_message,
                actor=actor_field,
                details=details,
                suggestion=suggestion,
            )

    # =========================================================================
    # Character Orientation Check
    # =========================================================================

    def _is_character_actor(self, actor: unreal.Actor) -> bool:
        """Check if an actor is a Character or Pawn type (including subclasses)."""
        return isinstance(actor, (unreal.Character, unreal.Pawn))

    def _check_character_orientation(self, actors: List[unreal.Actor], result: DiagnosticResult):
        """
        Check that all Pawn/Character actors are horizontally oriented.

        Characters should have pitch and roll within ±5° of horizontal.

        Args:
            actors: All actors in the level
            result: DiagnosticResult to add issues to
        """
        character_actors = [a for a in actors if self._is_character_actor(a)]

        for actor in character_actors:
            is_horizontal, pitch, roll = is_horizontal_orientation(
                actor, HORIZONTAL_TOLERANCE_DEGREES
            )

            if not is_horizontal:
                location = actor.get_actor_location()
                rotation = actor.get_actor_rotation()
                actor_name = actor.get_actor_label()
                class_name = actor.get_class().get_name()

                details = [
                    f"{_SEC_CONTEXT} {self._format_actor_context(actor_name, class_name, location.x, location.y, location.z)}",
                    f"{_SEC_DATA} Current rotation: Pitch={pitch:.1f}, Roll={roll:.1f}, Yaw={rotation.yaw:.1f}",
                    f"{_SEC_THRESHOLD} Horizontal tolerance: Pitch in {self._format_range(-HORIZONTAL_TOLERANCE_DEGREES, HORIZONTAL_TOLERANCE_DEGREES)}, Roll in {self._format_range(-HORIZONTAL_TOLERANCE_DEGREES, HORIZONTAL_TOLERANCE_DEGREES)}",
                ]

                violations = []
                if abs(pitch) > HORIZONTAL_TOLERANCE_DEGREES:
                    violations.append(
                        f"Pitch={pitch:.1f} exceeds tolerance by {abs(pitch) - HORIZONTAL_TOLERANCE_DEGREES:.1f} degrees"
                    )
                if abs(roll) > HORIZONTAL_TOLERANCE_DEGREES:
                    violations.append(
                        f"Roll={roll:.1f} exceeds tolerance by {abs(roll) - HORIZONTAL_TOLERANCE_DEGREES:.1f} degrees"
                    )
                if violations:
                    details.append(f"{_SEC_VIOLATION} {' | '.join(violations)}")

                details.extend([
                    f"{_SEC_EXPECTED} Character actors should be upright: Pitch=0 (+/-{HORIZONTAL_TOLERANCE_DEGREES:.1f}), Roll=0 (+/-{HORIZONTAL_TOLERANCE_DEGREES:.1f})",
                    f"{_SEC_IMPACT} Character appears tilted; movement, animations, and AI navigation may malfunction",
                ])

                result.add_issue(
                    IssueSeverity.WARNING,
                    "Orientation",
                    "Character tilted beyond horizontal tolerance (movement may malfunction)",
                    actor=actor_name,
                    details=details,
                    suggestion=f"Reset Character orientation: Set Pitch=0, Roll=0, keep Yaw={rotation.yaw:.1f} for facing direction; verify no collision or physics constraint causing tilt",
                )

    # =========================================================================
    # Duplicate Blueprint Detection
    # =========================================================================

    def _check_duplicate_blueprints(self, actors: List[unreal.Actor], result: DiagnosticResult):
        """
        Check for duplicate blueprint instances in the level.

        If multiple instances of the same blueprint class exist,
        report as a warning.

        Args:
            actors: All actors in the level
            result: DiagnosticResult to add issues to
        """
        # Count blueprint instances by class name
        blueprint_counts: Dict[str, List[str]] = {}

        for actor in actors:
            class_name = actor.get_class().get_name()

            # Blueprint classes end with _C
            if class_name.endswith("_C"):
                actor_label = actor.get_actor_label()

                if class_name not in blueprint_counts:
                    blueprint_counts[class_name] = []

                blueprint_counts[class_name].append(actor_label)

        # Report blueprints with multiple instances
        duplicate_count = 0
        for class_name, instances in blueprint_counts.items():
            if len(instances) > 1:
                duplicate_count += 1
                result.add_issue(
                    IssueSeverity.INFO,
                    "Blueprint",
                    f"Multiple instances of same Blueprint ({len(instances)} actors, review for duplicates)",
                    details=[
                        f"{_SEC_CONTEXT} Blueprint instance detection found multiple actors of same blueprint class",
                        f"{_SEC_DATA} Class: {class_name} | Instance count: {len(instances)}",
                        f"{_SEC_DATA} Instances: {', '.join(instances)}",
                        f"{_SEC_INFO} Multiple instances may be intentional (enemies, collectibles, props) or accidental duplicates",
                        f"{_SEC_EXPECTED} Review for: identical positions (duplicates), logical grouping (enemies), consistent configuration",
                    ],
                    suggestion="Review blueprint instances: Check for identical positions indicating accidental duplicates; verify intentional placement pattern",
                )

        result.metadata["blueprint_classes_with_duplicates"] = duplicate_count
        result.metadata["total_blueprint_classes"] = len(blueprint_counts)

    # =========================================================================
    # Lighting Actor Check
    # =========================================================================

    def _check_lighting_actors(self, actors: List[unreal.Actor], result: DiagnosticResult):
        """
        Check for essential lighting actors in the level.

        Warns if DirectionalLight, SkyLight, SkyAtmosphere, or ExponentialHeightFog
        are missing from the level.

        Args:
            actors: All actors in the level
            result: DiagnosticResult to add issues to
        """
        # Build a set of class names present in the level
        present_classes: Set[str] = set()
        for actor in actors:
            class_name = actor.get_class().get_name()
            present_classes.add(class_name.lower())

        # Check each essential lighting actor
        missing_actors = []
        found_actors = []

        for actor_class, description in ESSENTIAL_LIGHTING_ACTORS:
            # Check if this class or any subclass is present
            class_found = False
            for present in present_classes:
                if actor_class.lower() in present:
                    class_found = True
                    found_actors.append((actor_class, description))
                    break

            if not class_found:
                missing_actors.append((actor_class, description))

        # Store metadata
        result.metadata["lighting_actors_found"] = len(found_actors)
        result.metadata["lighting_actors_missing"] = len(missing_actors)

        # Report missing actors
        if missing_actors:
            missing_names = [name for name, _ in missing_actors]
            missing_details = [f"  - {name}: {desc}" for name, desc in missing_actors]
            found_details = [f"  - {name}: {desc}" for name, desc in found_actors] if found_actors else ["  - None"]

            result.add_issue(
                IssueSeverity.WARNING,
                "Lighting",
                f"Missing essential lighting actors ({len(missing_actors)} of {len(ESSENTIAL_LIGHTING_ACTORS)} not found)",
                details=[
                    f"{_SEC_CONTEXT} Level lighting completeness check for standard outdoor environment setup",
                    f"{_SEC_DATA} Essential lighting actors present ({len(found_actors)}):",
                    *found_details,
                    f"{_SEC_DATA} Essential lighting actors missing ({len(missing_actors)}):",
                    *missing_details,
                    f"{_SEC_EXPECTED} Complete lighting setup includes: DirectionalLight (sun), SkyLight (ambient), SkyAtmosphere (sky), ExponentialHeightFog (atmosphere)",
                    f"{_SEC_IMPACT} Level may appear dark, lack sky rendering, or miss atmospheric effects; lighting will not match typical outdoor scenes",
                    f"{_SEC_INFO} Indoor levels may intentionally omit some actors (e.g., SkyAtmosphere); review based on level type",
                ],
                suggestion=f"Add missing lighting actors: {', '.join(missing_names)}. Use Place Actors panel > Lights/Visual Effects categories, or drag from Content Browser",
            )

