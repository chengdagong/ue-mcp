# PIE (Play In Editor) tick-based code executor for UE5
#
# Executes Python code snippets at specified ticks during PIE runtime.
# Uses tick callbacks to track frame count and execute code at precise ticks.

import unreal
import os
import json
from datetime import datetime
from io import StringIO
import sys


# ============================================
# INTERNAL HELPERS
# ============================================

def _get_level_editor_subsystem():
    """
    Get the LevelEditorSubsystem.

    Returns:
        tuple: (subsystem, error_message) - subsystem is None if failed
    """
    subsystem = unreal.get_editor_subsystem(unreal.LevelEditorSubsystem)
    if not subsystem:
        return None, "Failed to get LevelEditorSubsystem"
    return subsystem, None


def _start_pie_session():
    """Start PIE (Play In Editor) session."""
    subsystem, error = _get_level_editor_subsystem()
    if error:
        unreal.log_error(f"[ERROR] {error}")
        return False

    if subsystem.is_in_play_in_editor():
        unreal.log_warning("[WARNING] PIE is already running")
        return False

    subsystem.editor_request_begin_play()
    unreal.log("[OK] PIE start requested")
    return True


def _stop_pie_session():
    """Stop PIE (Play In Editor) session."""
    subsystem, error = _get_level_editor_subsystem()
    if error:
        unreal.log_error(f"[ERROR] {error}")
        return False

    if not subsystem.is_in_play_in_editor():
        unreal.log_warning("[WARNING] PIE is not running")
        return False

    subsystem.editor_request_end_play()
    unreal.log("[OK] PIE stop requested")
    return True


# ============================================
# PIE TICK EXECUTOR CLASS
# ============================================

class PIETickExecutor:
    """PIE tick-based code executor using tick callbacks."""

    def __init__(
        self,
        total_ticks,
        code_snippets,
        auto_stop_pie=True,
        task_id=None,
        on_before_complete=None,
    ):
        """
        Initialize the PIE tick executor.

        Args:
            total_ticks: Total number of ticks to run PIE
            code_snippets: List of code snippet configurations, each with:
                - code: Python code string to execute
                - start_tick: Tick number to start execution (0-indexed)
                - execution_count: Number of consecutive ticks to execute (default: 1)
            auto_stop_pie: Whether to stop PIE session when total_ticks reached
            task_id: Unique task identifier for completion file (used by MCP server)
            on_before_complete: Callback function called before stopping PIE.
                                Signature: callback(executor) -> None
                                Use this to save data before PIE stops.
        """
        self.total_ticks = total_ticks
        self.code_snippets = code_snippets
        self.auto_stop_pie = auto_stop_pie
        self.task_id = task_id
        self.on_before_complete = on_before_complete

        # State variables
        self._tick_handle = None
        self._pie_begin_handle = None
        self._pie_end_handle = None
        self._tick_count = 0
        self._is_running = False
        self._is_in_pie = False
        self._is_complete = False
        self._result = None

        # Build execution schedule: {tick_number: [(snippet_index, code), ...]}
        self._schedule = self._build_schedule()

        # Execution results
        self._executions = []
        self._errors = []

        # Shared context for code execution (persists across snippets)
        self._exec_context = {
            "unreal": unreal,
            "__executor__": self,
        }

    def _build_schedule(self):
        """
        Build execution schedule from code snippets.

        Returns:
            dict: {tick_number: [(snippet_index, code), ...]}
        """
        schedule = {}
        for idx, snippet in enumerate(self.code_snippets):
            code = snippet.get("code", "")
            start_tick = snippet.get("start_tick", 0)
            execution_count = snippet.get("execution_count", 1)

            for i in range(execution_count):
                tick = start_tick + i
                if tick not in schedule:
                    schedule[tick] = []
                schedule[tick].append((idx, code))

        return schedule

    def start(self):
        """Start the executor."""
        if self._is_running:
            unreal.log_warning("[WARNING] PIE tick executor already running")
            return

        self._is_running = True
        self._tick_count = 0
        self._is_in_pie = False
        self._is_complete = False
        self._result = None
        self._executions = []
        self._errors = []

        # Reset shared context
        self._exec_context = {
            "unreal": unreal,
            "__executor__": self,
        }

        # Check if PIE is already running - stop it first for clean tick counting
        # Must do this BEFORE binding callbacks to avoid triggering on_end_pie
        pie_worlds = unreal.EditorLevelLibrary.get_pie_worlds(False)
        if len(pie_worlds) > 0:
            unreal.log("[INFO] PIE already running, stopping it first for clean tick counting")
            _stop_pie_session()

        # Bind PIE lifecycle events
        editor_utility = unreal.get_editor_subsystem(unreal.EditorUtilitySubsystem)
        self._pie_begin_handle = editor_utility.on_begin_pie.add_callable(self._on_pie_started)
        self._pie_end_handle = editor_utility.on_end_pie.add_callable(self._on_pie_ended)

        unreal.log(f"[OK] PIE tick executor started - {len(self.code_snippets)} snippets, {self.total_ticks} total ticks")

    def stop(self):
        """Stop the executor."""
        if not self._is_running:
            unreal.log_warning("[WARNING] PIE tick executor not running")
            return

        self._is_running = False

        # Unbind PIE lifecycle events
        editor_utility = unreal.get_editor_subsystem(unreal.EditorUtilitySubsystem)
        if self._pie_begin_handle is not None:
            editor_utility.on_begin_pie.remove_callable(self._pie_begin_handle)
            self._pie_begin_handle = None
        if self._pie_end_handle is not None:
            editor_utility.on_end_pie.remove_callable(self._pie_end_handle)
            self._pie_end_handle = None

        # Unregister tick callback
        if self._tick_handle is not None:
            unreal.unregister_slate_post_tick_callback(self._tick_handle)
            self._tick_handle = None

        self._is_in_pie = False
        unreal.log(f"[OK] PIE tick executor stopped - Executed {len(self._executions)} code blocks")

    def _on_pie_started(self, is_simulating):
        """Called when PIE session starts."""
        if not self._is_running:
            return

        if self._is_in_pie:
            return  # Already in PIE

        self._is_in_pie = True
        self._tick_count = 0  # Reset tick count when PIE starts

        # Register tick callback
        if self._tick_handle is None:
            self._tick_handle = unreal.register_slate_post_tick_callback(self._on_tick)

        unreal.log("[INFO] PIE started - beginning tick-based execution")

    def _on_pie_ended(self, is_simulating):
        """Called when PIE session ends."""
        if not self._is_running:
            return

        if not self._is_in_pie:
            return  # Not in PIE

        self._is_in_pie = False

        # Unregister tick callback
        if self._tick_handle is not None:
            unreal.unregister_slate_post_tick_callback(self._tick_handle)
            self._tick_handle = None

        unreal.log("[INFO] PIE ended - pausing execution")

    def _on_tick(self, delta_time):
        """Tick callback function - only called when PIE is running."""
        if not self._is_running or not self._is_in_pie:
            return

        # Execute scheduled code for current tick
        if self._tick_count in self._schedule:
            for snippet_index, code in self._schedule[self._tick_count]:
                self._execute_code(snippet_index, self._tick_count, code)

        # Increment tick count
        self._tick_count += 1

        # Check if total ticks reached - auto stop
        if self._tick_count >= self.total_ticks:
            self._auto_complete()

    def _execute_code(self, snippet_index, tick, code):
        """
        Execute a code snippet.

        Args:
            snippet_index: Index of the snippet in original list
            tick: Current tick number
            code: Python code string to execute
        """
        # Add current tick info to context
        self._exec_context["__tick__"] = tick
        self._exec_context["__snippet_index__"] = snippet_index

        # Capture stdout
        old_stdout = sys.stdout
        sys.stdout = captured_output = StringIO()

        success = True
        error_msg = None

        try:
            exec(code, self._exec_context)
        except Exception as e:
            success = False
            error_msg = str(e)
            unreal.log_error(f"[ERROR] Snippet {snippet_index} at tick {tick} failed: {e}")

        # Restore stdout and get output
        sys.stdout = old_stdout
        output = captured_output.getvalue()

        # Record execution result
        result = {
            "snippet_index": snippet_index,
            "tick": tick,
            "success": success,
            "output": output,
        }
        if error_msg:
            result["error"] = error_msg
            self._errors.append({
                "snippet_index": snippet_index,
                "tick": tick,
                "error": error_msg,
            })

        self._executions.append(result)

        if success:
            unreal.log(f"[OK] Executed snippet {snippet_index} at tick {tick}")

    def _auto_complete(self):
        """Auto-complete when total ticks reached (called from tick callback)."""
        if self._is_complete:
            return  # Already completed

        unreal.log(f"[INFO] Total ticks ({self.total_ticks}) reached, auto-stopping...")

        # Build result
        self._result = {
            "success": len(self._errors) == 0,
            "total_ticks": self.total_ticks,
            "executed_ticks": self._tick_count,
            "execution_count": len(self._executions),
            "executions": self._executions,
            "errors": self._errors,
        }

        # Call on_before_complete callback (before stopping PIE)
        # This allows callers to save data while PIE is still running
        if self.on_before_complete:
            try:
                self.on_before_complete(self)
            except Exception as e:
                unreal.log_error(f"[ERROR] on_before_complete callback failed: {e}")

        # Stop PIE if requested
        if self.auto_stop_pie:
            _stop_pie_session()

        # Stop executor
        self.stop()

        # Mark as complete
        self._is_complete = True

        unreal.log(f"[OK] PIE tick execution completed - {len(self._executions)} executions in {self._tick_count} ticks")

        # Write completion file for MCP server to detect
        if self.task_id:
            project_dir = unreal.Paths.project_dir()
            completion_file = os.path.join(project_dir, "Saved", "Logs", f"{self.task_id}_completed")
            with open(completion_file, "w", encoding="utf-8") as f:
                json.dump(self._result, f)
            unreal.log(f"[OK] Wrote completion file: {completion_file}")

    @property
    def is_complete(self):
        """Check if execution has completed."""
        return self._is_complete

    @property
    def tick_count(self):
        """Get current tick count."""
        return self._tick_count

    def get_result(self):
        """
        Get the execution result.

        Returns:
            dict with success, total_ticks, executed_ticks, executions, errors
            or None if not complete
        """
        return self._result

    def get_context(self):
        """
        Get the shared execution context.

        This allows snippets to share variables between executions.
        """
        return self._exec_context

    def request_start_pie(self):
        """Request to start PIE session."""
        _start_pie_session()

    def request_stop_pie(self):
        """Request to stop PIE session."""
        _stop_pie_session()


# ============================================
# MODULE-LEVEL FUNCTIONS
# ============================================

# Global instance
_executor_instance = None


def start_pie_tick_executor(
    total_ticks,
    code_snippets,
    auto_start_pie=False,
    auto_stop_pie=True,
    task_id=None,
    on_before_complete=None,
):
    """
    Start PIE tick-based code executor.

    Args:
        total_ticks: Total number of ticks to run
        code_snippets: List of code snippet configurations, each with:
            - code: Python code string
            - start_tick: Tick to start execution (0-indexed)
            - execution_count: Number of consecutive ticks to execute (default: 1)
        auto_start_pie: Whether to auto-start PIE
        auto_stop_pie: Whether to stop PIE when total_ticks reached
        task_id: Unique task identifier for completion file
        on_before_complete: Callback function called before stopping PIE.
                            Signature: callback(executor) -> None

    Returns:
        PIETickExecutor instance
    """
    global _executor_instance

    if _executor_instance is not None:
        _executor_instance.stop()

    _executor_instance = PIETickExecutor(
        total_ticks=total_ticks,
        code_snippets=code_snippets,
        auto_stop_pie=auto_stop_pie,
        task_id=task_id,
        on_before_complete=on_before_complete,
    )
    _executor_instance.start()

    # Auto-start PIE if requested
    if auto_start_pie:
        _start_pie_session()

    return _executor_instance


def stop_pie_tick_executor():
    """Stop PIE tick executor."""
    global _executor_instance
    if _executor_instance is not None:
        _executor_instance.stop()
        _executor_instance = None


def get_pie_tick_executor():
    """Get current executor instance."""
    return _executor_instance
