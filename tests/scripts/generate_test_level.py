"""
Auto-generate test level for UE-MCP pytest tests.

This script is executed via editor_execute_script MCP tool to create
a standardized test level with all required actors for integration tests.

The generated level includes:
- Floor (large StaticMeshActor for ground detection)
- PlayerStart (for PIE session spawn)
- Multiple BP_ThirdPersonCharacter (for actor tracing, PIE capture, and fuzzy matching)
- Multiple StaticMeshActors (for fuzzy matching tests)
- DirectionalLight and SkyLight (for basic lighting)
- SkyAtmosphere (for realistic blue sky)
- VolumetricCloud (for white clouds)
- ExponentialHeightFog (for atmospheric depth)

Usage:
    Called automatically by ensure_test_level fixture in conftest.py
"""

import json
import unreal


# Configuration
LEVEL_PATH = "/Game/Tests/AutoGeneratedTestLevel"
BP_CHARACTER_PATH = "/Game/ThirdPerson/Blueprints/BP_ThirdPersonCharacter"


def get_subsystems():
    """Get required editor subsystems."""
    level_subsystem = unreal.get_editor_subsystem(unreal.LevelEditorSubsystem)
    actor_subsystem = unreal.get_editor_subsystem(unreal.EditorActorSubsystem)
    return level_subsystem, actor_subsystem


def check_level_exists():
    """Check if the test level already exists."""
    return unreal.EditorAssetLibrary.does_asset_exist(LEVEL_PATH)


def create_floor(actor_subsystem):
    """Create a large floor for ground detection."""
    floor = actor_subsystem.spawn_actor_from_class(
        unreal.StaticMeshActor,
        unreal.Vector(0, 0, 0),
        unreal.Rotator(0, 0, 0)
    )
    floor.set_actor_label("Floor")
    floor.set_actor_scale3d(unreal.Vector(100, 100, 1))  # 10000x10000x100 units

    # Set cube mesh
    mesh_comp = floor.get_component_by_class(unreal.StaticMeshComponent)
    if mesh_comp:
        cube = unreal.load_asset("/Engine/BasicShapes/Cube")
        if cube:
            mesh_comp.set_static_mesh(cube)

    return floor


def create_player_start(actor_subsystem):
    """Create PlayerStart for PIE spawn point."""
    player_start = actor_subsystem.spawn_actor_from_class(
        unreal.PlayerStart,
        unreal.Vector(0, 0, 100),
        unreal.Rotator(0, 0, 0)
    )
    player_start.set_actor_label("PlayerStart")
    return player_start


def create_characters(actor_subsystem, count=2):
    """Create multiple BP_ThirdPersonCharacter for tracing and fuzzy matching tests."""
    bp_asset = unreal.load_asset(BP_CHARACTER_PATH)
    if not bp_asset:
        print(f"Warning: Could not load blueprint: {BP_CHARACTER_PATH}")
        return []

    # Get the generated class from the blueprint
    bp_class = bp_asset.generated_class()
    if not bp_class:
        print(f"Warning: Blueprint has no generated class: {BP_CHARACTER_PATH}")
        return []

    characters = []
    for i in range(count):
        character = actor_subsystem.spawn_actor_from_class(
            bp_class,
            unreal.Vector(300 + i * 200, i * 100, 100),
            unreal.Rotator(0, 180, 0)  # Face origin
        )
        if character:
            character.set_actor_label(f"BP_ThirdPersonCharacter_{i}")
            characters.append(character)

    return characters


def create_test_cubes(actor_subsystem, count=3):
    """Create multiple StaticMeshActors for fuzzy matching tests."""
    cubes = []
    cube_mesh = unreal.load_asset("/Engine/BasicShapes/Cube")

    for i in range(count):
        mesh_actor = actor_subsystem.spawn_actor_from_class(
            unreal.StaticMeshActor,
            unreal.Vector(i * 200 - 200, -500, 50),
            unreal.Rotator(0, 0, 0)
        )
        mesh_actor.set_actor_label(f"TestCube_{i}")

        # Set mesh
        mesh_comp = mesh_actor.get_component_by_class(unreal.StaticMeshComponent)
        if mesh_comp and cube_mesh:
            mesh_comp.set_static_mesh(cube_mesh)

        cubes.append(mesh_actor)
    return cubes


def create_lighting(actor_subsystem):
    """Create basic lighting for the level."""
    # Directional Light (Sun)
    dir_light = actor_subsystem.spawn_actor_from_class(
        unreal.DirectionalLight,
        unreal.Vector(0, 0, 1000),
        unreal.Rotator(-45, -30, 0)  # Angled for realistic sun position
    )
    dir_light.set_actor_label("DirectionalLight")

    # Configure directional light for atmosphere
    light_comp = dir_light.get_component_by_class(unreal.DirectionalLightComponent)
    if light_comp:
        light_comp.set_editor_property("intensity", 10.0)
        light_comp.set_editor_property("light_color", unreal.Color(255, 244, 214, 255))
        # Enable atmosphere sun light for sky atmosphere interaction
        light_comp.set_editor_property("atmosphere_sun_light", True)

    # Sky Light (captures sky for ambient lighting)
    sky_light = actor_subsystem.spawn_actor_from_class(
        unreal.SkyLight,
        unreal.Vector(0, 0, 500),
        unreal.Rotator(0, 0, 0)
    )
    sky_light.set_actor_label("SkyLight")

    # Configure sky light to capture from sky atmosphere
    skylight_comp = sky_light.get_component_by_class(unreal.SkyLightComponent)
    if skylight_comp:
        skylight_comp.set_editor_property("real_time_capture", True)

    return dir_light, sky_light


def create_sky_atmosphere(actor_subsystem):
    """Create sky atmosphere for realistic blue sky."""
    sky_atmo = actor_subsystem.spawn_actor_from_class(
        unreal.SkyAtmosphere,
        unreal.Vector(0, 0, 0),
        unreal.Rotator(0, 0, 0)
    )
    sky_atmo.set_actor_label("SkyAtmosphere")
    return sky_atmo


def create_volumetric_cloud(actor_subsystem):
    """Create volumetric clouds for white cloud effect."""
    vol_cloud = actor_subsystem.spawn_actor_from_class(
        unreal.VolumetricCloud,
        unreal.Vector(0, 0, 0),
        unreal.Rotator(0, 0, 0)
    )
    vol_cloud.set_actor_label("VolumetricCloud")
    return vol_cloud


def create_exponential_height_fog(actor_subsystem):
    """Create exponential height fog for atmospheric depth."""
    fog = actor_subsystem.spawn_actor_from_class(
        unreal.ExponentialHeightFog,
        unreal.Vector(0, 0, 100),
        unreal.Rotator(0, 0, 0)
    )
    fog.set_actor_label("ExponentialHeightFog")

    # Configure fog for subtle atmospheric effect
    fog_comp = fog.get_component_by_class(unreal.ExponentialHeightFogComponent)
    if fog_comp:
        fog_comp.set_editor_property("fog_density", 0.005)
        fog_comp.set_editor_property("fog_height_falloff", 0.2)
        # Note: property is fog_inscattering_luminance, not fog_inscattering_color
        fog_comp.set_editor_property("fog_inscattering_luminance", unreal.LinearColor(0.45, 0.6, 0.85, 1.0))
        # Note: property is enable_volumetric_fog, not volumetric_fog
        fog_comp.set_editor_property("enable_volumetric_fog", True)

    return fog


def create_test_level():
    """Create and populate test level with all required actors."""

    # Check if level already exists
    if check_level_exists():
        result = {
            "success": True,
            "level": LEVEL_PATH,
            "created": False,
            "message": "Level already exists"
        }
        print(f"__RESULT__{json.dumps(result)}")
        return result

    level_subsystem, actor_subsystem = get_subsystems()

    # Create new level
    # Note: new_level creates an empty level at the specified path
    success = unreal.EditorLevelLibrary.new_level(LEVEL_PATH)
    if not success:
        result = {
            "success": False,
            "error": f"Failed to create level at {LEVEL_PATH}"
        }
        print(f"__RESULT__{json.dumps(result)}")
        return result

    actors_created = []

    # Create all actors
    try:
        # 1. Floor
        floor = create_floor(actor_subsystem)
        if floor:
            actors_created.append("Floor")

        # 2. PlayerStart
        player_start = create_player_start(actor_subsystem)
        if player_start:
            actors_created.append("PlayerStart")

        # 3. Multiple BP_ThirdPersonCharacter (for tracing and fuzzy matching)
        characters = create_characters(actor_subsystem, 2)
        actors_created.extend([f"BP_ThirdPersonCharacter_{i}" for i in range(len(characters))])

        # 4. Multiple TestCubes (StaticMeshActors for fuzzy matching)
        cubes = create_test_cubes(actor_subsystem, 3)
        actors_created.extend([f"TestCube_{i}" for i in range(len(cubes))])

        # 5. Lighting
        dir_light, sky_light = create_lighting(actor_subsystem)
        if dir_light:
            actors_created.append("DirectionalLight")
        if sky_light:
            actors_created.append("SkyLight")

        # 6. Sky Atmosphere (blue sky)
        sky_atmo = create_sky_atmosphere(actor_subsystem)
        if sky_atmo:
            actors_created.append("SkyAtmosphere")

        # 7. Volumetric Cloud (white clouds)
        vol_cloud = create_volumetric_cloud(actor_subsystem)
        if vol_cloud:
            actors_created.append("VolumetricCloud")

        # 8. Exponential Height Fog (atmospheric depth)
        fog = create_exponential_height_fog(actor_subsystem)
        if fog:
            actors_created.append("ExponentialHeightFog")

    except Exception as e:
        result = {
            "success": False,
            "error": f"Failed to create actors: {str(e)}",
            "actors_created": actors_created
        }
        print(f"__RESULT__{json.dumps(result)}")
        return result

    # Save the level
    try:
        unreal.EditorLevelLibrary.save_current_level()
    except Exception as e:
        result = {
            "success": False,
            "error": f"Failed to save level: {str(e)}",
            "actors_created": actors_created
        }
        print(f"__RESULT__{json.dumps(result)}")
        return result

    result = {
        "success": True,
        "level": LEVEL_PATH,
        "created": True,
        "actors_created": actors_created,
        "message": f"Test level created with {len(actors_created)} actors"
    }
    print(f"__RESULT__{json.dumps(result)}")
    return result


# Entry point when executed as script
if __name__ == "__main__":
    create_test_level()
