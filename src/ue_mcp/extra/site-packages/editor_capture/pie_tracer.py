# PIE (Play In Editor) actor transform tracing for UE5
#
# Traces specified actors' transforms (location, rotation, velocity) during PIE
# runtime using tick callbacks at regular intervals.

import unreal
import os
import json
from datetime import datetime


# ============================================
# INTERNAL HELPERS
# ============================================

def _get_level_editor_subsystem():
    """
    Get the LevelEditorSubsystem.

    Returns:
        tuple: (subsystem, error_message) - subsystem is None if failed
    """
    subsystem = unreal.get_editor_subsystem(unreal.LevelEditorSubsystem)
    if not subsystem:
        return None, "Failed to get LevelEditorSubsystem"
    return subsystem, None


def _start_pie_session():
    """Start PIE (Play In Editor) session."""
    subsystem, error = _get_level_editor_subsystem()
    if error:
        unreal.log_error(f"[ERROR] {error}")
        return False

    if subsystem.is_in_play_in_editor():
        unreal.log_warning("[WARNING] PIE is already running")
        return False

    subsystem.editor_request_begin_play()
    unreal.log("[OK] PIE start requested")
    return True


def _stop_pie_session():
    """Stop PIE (Play In Editor) session."""
    subsystem, error = _get_level_editor_subsystem()
    if error:
        unreal.log_error(f"[ERROR] {error}")
        return False

    if not subsystem.is_in_play_in_editor():
        unreal.log_warning("[WARNING] PIE is not running")
        return False

    subsystem.editor_request_end_play()
    unreal.log("[OK] PIE stop requested")
    return True


def _ensure_output_directory(path):
    """
    Ensure output directory exists, creating it if necessary.

    Args:
        path: File path to ensure parent directory exists
    """
    dir_path = os.path.dirname(path)
    if dir_path and not os.path.exists(dir_path):
        os.makedirs(dir_path)
        unreal.log(f"[INFO] Created output directory: {dir_path}")


# ============================================
# PIE TRACER CLASS
# ============================================

class PIETracer:
    """PIE actor transform tracer using tick callbacks."""

    def __init__(
        self,
        output_file,
        actor_names,
        interval_seconds=0.1,
        duration=None,
        auto_stop_pie=True,
        task_id=None
    ):
        """
        Initialize the PIE tracer.

        Args:
            output_file: JSON output file path
            actor_names: List of actor names to track
            interval_seconds: Sampling interval in seconds
            duration: Auto-stop after this many seconds (None = run indefinitely)
            auto_stop_pie: Whether to stop PIE session when duration is reached
            task_id: Unique task identifier for completion file (used by MCP server)
        """
        self.output_file = output_file
        self.actor_names = actor_names
        self.interval_seconds = interval_seconds
        self.duration = duration
        self.auto_stop_pie = auto_stop_pie
        self.task_id = task_id

        # State variables
        self._tick_handle = None
        self._pie_begin_handle = None
        self._pie_end_handle = None
        self._accumulated_time = 0.0
        self._total_elapsed = 0.0
        self._sample_count = 0
        self._is_running = False
        self._is_in_pie = False
        self._is_complete = False
        self._result = None

        # Actor tracking
        self._actor_refs = {}  # {name: actor_object}
        self._actors_not_found = []

        # Trace data
        self._trace_data = {
            "actors": {},  # {actor_name: [samples]}
            "metadata": {
                "level": "",
                "start_time": "",
                "end_time": "",
                "duration": 0.0,
                "interval": interval_seconds,
                "sample_count": 0,
            }
        }

        # Ensure output directory exists
        _ensure_output_directory(self.output_file)

    def start(self):
        """Start the tracer."""
        if self._is_running:
            unreal.log_warning("[WARNING] PIE tracer already running")
            return

        self._is_running = True
        self._accumulated_time = 0.0
        self._total_elapsed = 0.0
        self._sample_count = 0
        self._is_in_pie = False
        self._is_complete = False
        self._result = None
        self._actor_refs = {}
        self._actors_not_found = []

        # Initialize trace data
        self._trace_data = {
            "actors": {},
            "metadata": {
                "level": "",
                "start_time": datetime.now().isoformat(),
                "end_time": "",
                "duration": 0.0,
                "interval": self.interval_seconds,
                "sample_count": 0,
            }
        }

        # Bind PIE lifecycle events
        editor_utility = unreal.get_editor_subsystem(unreal.EditorUtilitySubsystem)
        if editor_utility:
            self._pie_begin_handle = editor_utility.on_begin_pie.add_callable(self._on_pie_started)
            self._pie_end_handle = editor_utility.on_end_pie.add_callable(self._on_pie_ended)
        else:
            unreal.log_error("[ERROR] Failed to get EditorUtilitySubsystem for PIE events")
            self._is_running = False
            return

        # Check if PIE is already running
        pie_worlds = unreal.EditorLevelLibrary.get_pie_worlds(False)
        pie_already_running = len(pie_worlds) > 0

        # Handle late start if PIE already running
        if pie_already_running:
            unreal.log("[INFO] PIE already running, starting trace immediately")
            self._on_pie_started(False)

        unreal.log(f"[OK] PIE tracer started - Tracking {len(self.actor_names)} actors")
        unreal.log(f"[INFO] Interval: {self.interval_seconds}s, Output: {self.output_file}")

    def stop(self):
        """Stop the tracer."""
        if not self._is_running:
            unreal.log_warning("[WARNING] PIE tracer not running")
            return

        self._is_running = False

        # Unbind PIE lifecycle events
        editor_utility = unreal.get_editor_subsystem(unreal.EditorUtilitySubsystem)
        if editor_utility:
            if self._pie_begin_handle is not None:
                editor_utility.on_begin_pie.remove_callable(self._pie_begin_handle)
                self._pie_begin_handle = None
            if self._pie_end_handle is not None:
                editor_utility.on_end_pie.remove_callable(self._pie_end_handle)
                self._pie_end_handle = None

        # Unregister tick callback
        if self._tick_handle is not None:
            unreal.unregister_slate_post_tick_callback(self._tick_handle)
            self._tick_handle = None

        self._is_in_pie = False
        unreal.log(f"[OK] PIE tracer stopped - Total samples: {self._sample_count}")

    def _on_pie_started(self, is_simulating):
        """Called when PIE session starts."""
        if not self._is_running:
            return

        if self._is_in_pie:
            return  # Already in PIE

        self._is_in_pie = True
        self._accumulated_time = 0.0

        # Get level name
        pie_worlds = unreal.EditorLevelLibrary.get_pie_worlds(False)
        if len(pie_worlds) > 0:
            pie_world = pie_worlds[0]
            level_name = pie_world.get_name()
            self._trace_data["metadata"]["level"] = level_name

        # Register tick callback
        if self._tick_handle is None:
            self._tick_handle = unreal.register_slate_post_tick_callback(self._on_tick)

        unreal.log("[INFO] PIE started - beginning actor tracing")

    def _on_pie_ended(self, is_simulating):
        """Called when PIE session ends."""
        if not self._is_running:
            return

        if not self._is_in_pie:
            return  # Not in PIE

        self._is_in_pie = False

        # Unregister tick callback
        if self._tick_handle is not None:
            unreal.unregister_slate_post_tick_callback(self._tick_handle)
            self._tick_handle = None

        unreal.log("[INFO] PIE ended - pausing trace")

    def _find_actors(self, pie_world):
        """
        Find actor references by name in PIE world.

        Returns:
            Number of actors successfully found
        """
        all_actors = unreal.GameplayStatics.get_all_actors_of_class(
            pie_world, unreal.Actor
        )

        for target_name in self.actor_names:
            matches = []

            for actor in all_actors:
                # Try label first (user-friendly name in editor)
                label = actor.get_actor_label()
                if label.lower() == target_name.lower():
                    matches.append(actor)
                    continue

                # Try class name (e.g., "BP_PlayerCharacter_C")
                class_name = actor.get_class().get_name()
                if class_name.lower() == target_name.lower():
                    matches.append(actor)
                    continue

                # Try partial match on label
                if target_name.lower() in label.lower():
                    matches.append(actor)

            if matches:
                if len(matches) > 1:
                    unreal.log_warning(
                        f"[WARNING] Multiple actors match '{target_name}', using first match"
                    )
                self._actor_refs[target_name] = matches[0]
                self._trace_data["actors"][target_name] = []
                unreal.log(f"[OK] Found actor: {target_name} -> {matches[0].get_actor_label()}")
            else:
                self._actors_not_found.append(target_name)
                unreal.log_warning(f"[WARNING] Actor not found: {target_name}")

        return len(self._actor_refs)

    def _sample_actor(self, actor, timestamp):
        """
        Sample a single actor's transform data.

        Args:
            actor: Actor to sample
            timestamp: Current timestamp in seconds

        Returns:
            dict with timestamp, location, rotation, velocity
        """
        # Get location
        loc = actor.get_actor_location()

        # Get rotation
        rot = actor.get_actor_rotation()

        # Get velocity (if available)
        velocity = None
        if hasattr(actor, 'get_velocity'):
            try:
                vel = actor.get_velocity()
                if vel:  # Check not None
                    velocity = {"x": vel.x, "y": vel.y, "z": vel.z}
            except (AttributeError, RuntimeError):
                pass  # Actor doesn't support velocity

        return {
            "timestamp": round(timestamp, 3),
            "location": {"x": round(loc.x, 2), "y": round(loc.y, 2), "z": round(loc.z, 2)},
            "rotation": {"pitch": round(rot.pitch, 2), "yaw": round(rot.yaw, 2), "roll": round(rot.roll, 2)},
            "velocity": velocity,
        }

    def _on_tick(self, delta_time):
        """Tick callback function - only called when PIE is running."""
        if not self._is_running or not self._is_in_pie:
            return

        # Track total elapsed time for duration check
        self._total_elapsed += delta_time

        # Check if duration reached - auto stop
        if self.duration is not None and self._total_elapsed >= self.duration:
            self._auto_complete()
            return

        # Accumulate time for interval
        self._accumulated_time += delta_time

        # Check if sample interval reached
        if self._accumulated_time >= self.interval_seconds:
            # Subtract interval, preserve remainder to prevent drift
            self._accumulated_time -= self.interval_seconds

            # Get PIE world
            pie_worlds = unreal.EditorLevelLibrary.get_pie_worlds(False)
            if len(pie_worlds) == 0:
                return  # PIE ended between event and tick

            pie_world = pie_worlds[0]

            # Lazy actor discovery on first sample
            if not self._actor_refs and self._sample_count == 0:
                found_count = self._find_actors(pie_world)
                if found_count == 0:
                    unreal.log_error("[ERROR] No actors found to track, stopping tracer")
                    self._auto_complete()
                    return

            # Sample each tracked actor
            for name, actor in self._actor_refs.items():
                try:
                    sample = self._sample_actor(actor, self._total_elapsed)
                    self._trace_data["actors"][name].append(sample)
                except (RuntimeError, ReferenceError):
                    # Actor was destroyed during PIE
                    unreal.log_warning(f"[WARNING] Actor '{name}' is no longer valid, skipping")
                    continue

            self._sample_count += 1

    def _auto_complete(self):
        """Auto-complete when duration is reached (called from tick callback)."""
        if self._is_complete:
            return  # Already completed

        unreal.log(f"[INFO] Duration ({self.duration}s) reached, auto-stopping...")

        # Update metadata
        self._trace_data["metadata"]["duration"] = round(self._total_elapsed, 3)
        self._trace_data["metadata"]["sample_count"] = self._sample_count
        self._trace_data["metadata"]["end_time"] = datetime.now().isoformat()

        # Write trace file
        try:
            with open(self.output_file, "w", encoding="utf-8") as f:
                json.dump(self._trace_data, f, indent=2)
            unreal.log(f"[OK] Wrote trace file: {self.output_file}")
        except Exception as e:
            unreal.log_error(f"[ERROR] Failed to write trace file: {e}")

        # Build result
        self._result = {
            "success": True,
            "output_file": self.output_file,
            "duration": self._total_elapsed,
            "interval": self.interval_seconds,
            "sample_count": self._sample_count,
            "actor_count": len(self._actor_refs),
            "actors_not_found": self._actors_not_found,
        }

        # Stop PIE if requested
        if self.auto_stop_pie:
            _stop_pie_session()

        # Stop tracer
        self.stop()

        # Mark as complete
        self._is_complete = True

        unreal.log(f"[OK] PIE tracing completed - {self._sample_count} samples in {self._total_elapsed:.1f}s")

        # Write completion file for MCP server to detect
        if self.task_id:
            project_dir = unreal.Paths.project_dir()
            completion_file = os.path.join(project_dir, "Saved", "Logs", f"{self.task_id}_completed")
            with open(completion_file, "w", encoding="utf-8") as f:
                json.dump(self._result, f)
            unreal.log(f"[OK] Wrote completion file: {completion_file}")

    @property
    def is_complete(self):
        """Check if tracing has completed (duration reached or manually stopped)."""
        return self._is_complete

    def get_result(self):
        """
        Get the trace result.

        Returns:
            dict with success, output_file, duration, interval, sample_count, actor_count, actors_not_found
            or None if not complete
        """
        return self._result


# ============================================
# MODULE-LEVEL FUNCTIONS
# ============================================

# Global instance
_tracer_instance = None


def start_pie_tracer(
    output_file,
    actor_names,
    interval_seconds=0.1,
    auto_start_pie=False,
    duration=None,
    auto_stop_pie=True,
    task_id=None
):
    """
    Start PIE actor tracer.

    Args:
        output_file: JSON output file path
        actor_names: List of actor names to track
        interval_seconds: Sampling interval in seconds
        auto_start_pie: Whether to auto-start PIE
        duration: Auto-stop after this many seconds
        auto_stop_pie: Whether to stop PIE when duration reached
        task_id: Unique task identifier for completion file

    Returns:
        PIETracer instance
    """
    global _tracer_instance

    if _tracer_instance is not None:
        _tracer_instance.stop()

    _tracer_instance = PIETracer(
        output_file=output_file,
        actor_names=actor_names,
        interval_seconds=interval_seconds,
        duration=duration,
        auto_stop_pie=auto_stop_pie,
        task_id=task_id
    )
    _tracer_instance.start()

    # Auto-start PIE if requested
    if auto_start_pie:
        _start_pie_session()

    return _tracer_instance


def stop_pie_tracer():
    """Stop PIE actor tracer."""
    global _tracer_instance
    if _tracer_instance is not None:
        _tracer_instance.stop()
        _tracer_instance = None


def get_pie_tracer():
    """Get current tracer instance."""
    return _tracer_instance
